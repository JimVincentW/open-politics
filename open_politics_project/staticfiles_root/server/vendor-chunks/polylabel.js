"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/polylabel";
exports.ids = ["vendor-chunks/polylabel"];
exports.modules = {

/***/ "(ssr)/./node_modules/polylabel/polylabel.js":
/*!*********************************************!*\
  !*** ./node_modules/polylabel/polylabel.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar Queue = __webpack_require__(/*! tinyqueue */ \"(ssr)/./node_modules/tinyqueue/index.js\");\n\nif (Queue.default) Queue = Queue.default; // temporary webpack fix\n\nmodule.exports = polylabel;\nmodule.exports[\"default\"] = polylabel;\n\nfunction polylabel(polygon, precision, debug) {\n    precision = precision || 1.0;\n\n    // find the bounding box of the outer ring\n    var minX, minY, maxX, maxY;\n    for (var i = 0; i < polygon[0].length; i++) {\n        var p = polygon[0][i];\n        if (!i || p[0] < minX) minX = p[0];\n        if (!i || p[1] < minY) minY = p[1];\n        if (!i || p[0] > maxX) maxX = p[0];\n        if (!i || p[1] > maxY) maxY = p[1];\n    }\n\n    var width = maxX - minX;\n    var height = maxY - minY;\n    var cellSize = Math.min(width, height);\n    var h = cellSize / 2;\n\n    if (cellSize === 0) {\n        var degeneratePoleOfInaccessibility = [minX, minY];\n        degeneratePoleOfInaccessibility.distance = 0;\n        return degeneratePoleOfInaccessibility;\n    }\n\n    // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n    var cellQueue = new Queue(undefined, compareMax);\n\n    // cover polygon with initial cells\n    for (var x = minX; x < maxX; x += cellSize) {\n        for (var y = minY; y < maxY; y += cellSize) {\n            cellQueue.push(new Cell(x + h, y + h, h, polygon));\n        }\n    }\n\n    // take centroid as the first best guess\n    var bestCell = getCentroidCell(polygon);\n\n    // special case for rectangular polygons\n    var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);\n    if (bboxCell.d > bestCell.d) bestCell = bboxCell;\n\n    var numProbes = cellQueue.length;\n\n    while (cellQueue.length) {\n        // pick the most promising cell from the queue\n        var cell = cellQueue.pop();\n\n        // update the best cell if we found a better one\n        if (cell.d > bestCell.d) {\n            bestCell = cell;\n            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n        }\n\n        // do not drill down further if there's no chance of a better solution\n        if (cell.max - bestCell.d <= precision) continue;\n\n        // split the cell into four cells\n        h = cell.h / 2;\n        cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));\n        numProbes += 4;\n    }\n\n    if (debug) {\n        console.log('num probes: ' + numProbes);\n        console.log('best distance: ' + bestCell.d);\n    }\n\n    var poleOfInaccessibility = [bestCell.x, bestCell.y];\n    poleOfInaccessibility.distance = bestCell.d;\n    return poleOfInaccessibility;\n}\n\nfunction compareMax(a, b) {\n    return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n    this.x = x; // cell center x\n    this.y = y; // cell center y\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(x, y, polygon) {\n    var inside = false;\n    var minDistSq = Infinity;\n\n    for (var k = 0; k < polygon.length; k++) {\n        var ring = polygon[k];\n\n        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n            var a = ring[i];\n            var b = ring[j];\n\n            if ((a[1] > y !== b[1] > y) &&\n                (x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0])) inside = !inside;\n\n            minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));\n        }\n    }\n\n    return minDistSq === 0 ? 0 : (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n    var area = 0;\n    var x = 0;\n    var y = 0;\n    var points = polygon[0];\n\n    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        var a = points[i];\n        var b = points[j];\n        var f = a[0] * b[1] - b[0] * a[1];\n        x += (a[0] + b[0]) * f;\n        y += (a[1] + b[1]) * f;\n        area += f * 3;\n    }\n    if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);\n    return new Cell(x / area, y / area, 0, polygon);\n}\n\n// get squared distance from a point to a segment\nfunction getSegDistSq(px, py, a, b) {\n\n    var x = a[0];\n    var y = a[1];\n    var dx = b[0] - x;\n    var dy = b[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = b[0];\n            y = b[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9seWxhYmVsL3BvbHlsYWJlbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMERBQVc7O0FBRS9CLDBDQUEwQzs7QUFFMUM7QUFDQSx5QkFBc0I7O0FBRXRCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0RBQWdEO0FBQ2hELDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDOztBQUVBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtZ2VuZXJhdGlvbi1pbnRlcmZhY2UvLi9ub2RlX21vZHVsZXMvcG9seWxhYmVsL3BvbHlsYWJlbC5qcz8zODdhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFF1ZXVlID0gcmVxdWlyZSgndGlueXF1ZXVlJyk7XG5cbmlmIChRdWV1ZS5kZWZhdWx0KSBRdWV1ZSA9IFF1ZXVlLmRlZmF1bHQ7IC8vIHRlbXBvcmFyeSB3ZWJwYWNrIGZpeFxuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlsYWJlbDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBwb2x5bGFiZWw7XG5cbmZ1bmN0aW9uIHBvbHlsYWJlbChwb2x5Z29uLCBwcmVjaXNpb24sIGRlYnVnKSB7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDEuMDtcblxuICAgIC8vIGZpbmQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgb3V0ZXIgcmluZ1xuICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvblswXS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcCA9IHBvbHlnb25bMF1baV07XG4gICAgICAgIGlmICghaSB8fCBwWzBdIDwgbWluWCkgbWluWCA9IHBbMF07XG4gICAgICAgIGlmICghaSB8fCBwWzFdIDwgbWluWSkgbWluWSA9IHBbMV07XG4gICAgICAgIGlmICghaSB8fCBwWzBdID4gbWF4WCkgbWF4WCA9IHBbMF07XG4gICAgICAgIGlmICghaSB8fCBwWzFdID4gbWF4WSkgbWF4WSA9IHBbMV07XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoID0gbWF4WCAtIG1pblg7XG4gICAgdmFyIGhlaWdodCA9IG1heFkgLSBtaW5ZO1xuICAgIHZhciBjZWxsU2l6ZSA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBoID0gY2VsbFNpemUgLyAyO1xuXG4gICAgaWYgKGNlbGxTaXplID09PSAwKSB7XG4gICAgICAgIHZhciBkZWdlbmVyYXRlUG9sZU9mSW5hY2Nlc3NpYmlsaXR5ID0gW21pblgsIG1pblldO1xuICAgICAgICBkZWdlbmVyYXRlUG9sZU9mSW5hY2Nlc3NpYmlsaXR5LmRpc3RhbmNlID0gMDtcbiAgICAgICAgcmV0dXJuIGRlZ2VuZXJhdGVQb2xlT2ZJbmFjY2Vzc2liaWxpdHk7XG4gICAgfVxuXG4gICAgLy8gYSBwcmlvcml0eSBxdWV1ZSBvZiBjZWxscyBpbiBvcmRlciBvZiB0aGVpciBcInBvdGVudGlhbFwiIChtYXggZGlzdGFuY2UgdG8gcG9seWdvbilcbiAgICB2YXIgY2VsbFF1ZXVlID0gbmV3IFF1ZXVlKHVuZGVmaW5lZCwgY29tcGFyZU1heCk7XG5cbiAgICAvLyBjb3ZlciBwb2x5Z29uIHdpdGggaW5pdGlhbCBjZWxsc1xuICAgIGZvciAodmFyIHggPSBtaW5YOyB4IDwgbWF4WDsgeCArPSBjZWxsU2l6ZSkge1xuICAgICAgICBmb3IgKHZhciB5ID0gbWluWTsgeSA8IG1heFk7IHkgKz0gY2VsbFNpemUpIHtcbiAgICAgICAgICAgIGNlbGxRdWV1ZS5wdXNoKG5ldyBDZWxsKHggKyBoLCB5ICsgaCwgaCwgcG9seWdvbikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGFrZSBjZW50cm9pZCBhcyB0aGUgZmlyc3QgYmVzdCBndWVzc1xuICAgIHZhciBiZXN0Q2VsbCA9IGdldENlbnRyb2lkQ2VsbChwb2x5Z29uKTtcblxuICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgcmVjdGFuZ3VsYXIgcG9seWdvbnNcbiAgICB2YXIgYmJveENlbGwgPSBuZXcgQ2VsbChtaW5YICsgd2lkdGggLyAyLCBtaW5ZICsgaGVpZ2h0IC8gMiwgMCwgcG9seWdvbik7XG4gICAgaWYgKGJib3hDZWxsLmQgPiBiZXN0Q2VsbC5kKSBiZXN0Q2VsbCA9IGJib3hDZWxsO1xuXG4gICAgdmFyIG51bVByb2JlcyA9IGNlbGxRdWV1ZS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoY2VsbFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAvLyBwaWNrIHRoZSBtb3N0IHByb21pc2luZyBjZWxsIGZyb20gdGhlIHF1ZXVlXG4gICAgICAgIHZhciBjZWxsID0gY2VsbFF1ZXVlLnBvcCgpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYmVzdCBjZWxsIGlmIHdlIGZvdW5kIGEgYmV0dGVyIG9uZVxuICAgICAgICBpZiAoY2VsbC5kID4gYmVzdENlbGwuZCkge1xuICAgICAgICAgICAgYmVzdENlbGwgPSBjZWxsO1xuICAgICAgICAgICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZygnZm91bmQgYmVzdCAlZCBhZnRlciAlZCBwcm9iZXMnLCBNYXRoLnJvdW5kKDFlNCAqIGNlbGwuZCkgLyAxZTQsIG51bVByb2Jlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkbyBub3QgZHJpbGwgZG93biBmdXJ0aGVyIGlmIHRoZXJlJ3Mgbm8gY2hhbmNlIG9mIGEgYmV0dGVyIHNvbHV0aW9uXG4gICAgICAgIGlmIChjZWxsLm1heCAtIGJlc3RDZWxsLmQgPD0gcHJlY2lzaW9uKSBjb250aW51ZTtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgY2VsbCBpbnRvIGZvdXIgY2VsbHNcbiAgICAgICAgaCA9IGNlbGwuaCAvIDI7XG4gICAgICAgIGNlbGxRdWV1ZS5wdXNoKG5ldyBDZWxsKGNlbGwueCAtIGgsIGNlbGwueSAtIGgsIGgsIHBvbHlnb24pKTtcbiAgICAgICAgY2VsbFF1ZXVlLnB1c2gobmV3IENlbGwoY2VsbC54ICsgaCwgY2VsbC55IC0gaCwgaCwgcG9seWdvbikpO1xuICAgICAgICBjZWxsUXVldWUucHVzaChuZXcgQ2VsbChjZWxsLnggLSBoLCBjZWxsLnkgKyBoLCBoLCBwb2x5Z29uKSk7XG4gICAgICAgIGNlbGxRdWV1ZS5wdXNoKG5ldyBDZWxsKGNlbGwueCArIGgsIGNlbGwueSArIGgsIGgsIHBvbHlnb24pKTtcbiAgICAgICAgbnVtUHJvYmVzICs9IDQ7XG4gICAgfVxuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdudW0gcHJvYmVzOiAnICsgbnVtUHJvYmVzKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2Jlc3QgZGlzdGFuY2U6ICcgKyBiZXN0Q2VsbC5kKTtcbiAgICB9XG5cbiAgICB2YXIgcG9sZU9mSW5hY2Nlc3NpYmlsaXR5ID0gW2Jlc3RDZWxsLngsIGJlc3RDZWxsLnldO1xuICAgIHBvbGVPZkluYWNjZXNzaWJpbGl0eS5kaXN0YW5jZSA9IGJlc3RDZWxsLmQ7XG4gICAgcmV0dXJuIHBvbGVPZkluYWNjZXNzaWJpbGl0eTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU1heChhLCBiKSB7XG4gICAgcmV0dXJuIGIubWF4IC0gYS5tYXg7XG59XG5cbmZ1bmN0aW9uIENlbGwoeCwgeSwgaCwgcG9seWdvbikge1xuICAgIHRoaXMueCA9IHg7IC8vIGNlbGwgY2VudGVyIHhcbiAgICB0aGlzLnkgPSB5OyAvLyBjZWxsIGNlbnRlciB5XG4gICAgdGhpcy5oID0gaDsgLy8gaGFsZiB0aGUgY2VsbCBzaXplXG4gICAgdGhpcy5kID0gcG9pbnRUb1BvbHlnb25EaXN0KHgsIHksIHBvbHlnb24pOyAvLyBkaXN0YW5jZSBmcm9tIGNlbGwgY2VudGVyIHRvIHBvbHlnb25cbiAgICB0aGlzLm1heCA9IHRoaXMuZCArIHRoaXMuaCAqIE1hdGguU1FSVDI7IC8vIG1heCBkaXN0YW5jZSB0byBwb2x5Z29uIHdpdGhpbiBhIGNlbGxcbn1cblxuLy8gc2lnbmVkIGRpc3RhbmNlIGZyb20gcG9pbnQgdG8gcG9seWdvbiBvdXRsaW5lIChuZWdhdGl2ZSBpZiBwb2ludCBpcyBvdXRzaWRlKVxuZnVuY3Rpb24gcG9pbnRUb1BvbHlnb25EaXN0KHgsIHksIHBvbHlnb24pIHtcbiAgICB2YXIgaW5zaWRlID0gZmFsc2U7XG4gICAgdmFyIG1pbkRpc3RTcSA9IEluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBwb2x5Z29uLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciByaW5nID0gcG9seWdvbltrXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmluZy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHJpbmdbaV07XG4gICAgICAgICAgICB2YXIgYiA9IHJpbmdbal07XG5cbiAgICAgICAgICAgIGlmICgoYVsxXSA+IHkgIT09IGJbMV0gPiB5KSAmJlxuICAgICAgICAgICAgICAgICh4IDwgKGJbMF0gLSBhWzBdKSAqICh5IC0gYVsxXSkgLyAoYlsxXSAtIGFbMV0pICsgYVswXSkpIGluc2lkZSA9ICFpbnNpZGU7XG5cbiAgICAgICAgICAgIG1pbkRpc3RTcSA9IE1hdGgubWluKG1pbkRpc3RTcSwgZ2V0U2VnRGlzdFNxKHgsIHksIGEsIGIpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW5EaXN0U3EgPT09IDAgPyAwIDogKGluc2lkZSA/IDEgOiAtMSkgKiBNYXRoLnNxcnQobWluRGlzdFNxKTtcbn1cblxuLy8gZ2V0IHBvbHlnb24gY2VudHJvaWRcbmZ1bmN0aW9uIGdldENlbnRyb2lkQ2VsbChwb2x5Z29uKSB7XG4gICAgdmFyIGFyZWEgPSAwO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIHBvaW50cyA9IHBvbHlnb25bMF07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcbiAgICAgICAgdmFyIGEgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciBiID0gcG9pbnRzW2pdO1xuICAgICAgICB2YXIgZiA9IGFbMF0gKiBiWzFdIC0gYlswXSAqIGFbMV07XG4gICAgICAgIHggKz0gKGFbMF0gKyBiWzBdKSAqIGY7XG4gICAgICAgIHkgKz0gKGFbMV0gKyBiWzFdKSAqIGY7XG4gICAgICAgIGFyZWEgKz0gZiAqIDM7XG4gICAgfVxuICAgIGlmIChhcmVhID09PSAwKSByZXR1cm4gbmV3IENlbGwocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0sIDAsIHBvbHlnb24pO1xuICAgIHJldHVybiBuZXcgQ2VsbCh4IC8gYXJlYSwgeSAvIGFyZWEsIDAsIHBvbHlnb24pO1xufVxuXG4vLyBnZXQgc3F1YXJlZCBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50XG5mdW5jdGlvbiBnZXRTZWdEaXN0U3EocHgsIHB5LCBhLCBiKSB7XG5cbiAgICB2YXIgeCA9IGFbMF07XG4gICAgdmFyIHkgPSBhWzFdO1xuICAgIHZhciBkeCA9IGJbMF0gLSB4O1xuICAgIHZhciBkeSA9IGJbMV0gLSB5O1xuXG4gICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG5cbiAgICAgICAgdmFyIHQgPSAoKHB4IC0geCkgKiBkeCArIChweSAtIHkpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICAgIHggPSBiWzBdO1xuICAgICAgICAgICAgeSA9IGJbMV07XG5cbiAgICAgICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgICAgICAgeCArPSBkeCAqIHQ7XG4gICAgICAgICAgICB5ICs9IGR5ICogdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGR4ID0gcHggLSB4O1xuICAgIGR5ID0gcHkgLSB5O1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/polylabel/polylabel.js\n");

/***/ })

};
;