module.exports = {

"[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapSeries.js [app-ssr] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {
"use strict";

__turbopack_esm__({
    "MapSeries": ()=>MapSeries
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Series$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/render/Series.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Object.js [app-ssr] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
class MapSeries extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Series$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Series"] {
    constructor(){
        super(...arguments);
        Object.defineProperty(this, "_types", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_geometries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_geoJSONparsed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_excluded", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_notIncluded", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    _afterNew() {
        this.fields.push("geometry", "geometryType");
        this._setRawDefault("geometryField", "geometry");
        this._setRawDefault("geometryTypeField", "geometryType");
        this._setRawDefault("idField", "id");
        this.on("geoJSON", (geoJSON)=>{
            let previous = this._prevSettings.geoJSON;
            if (previous && previous != geoJSON) {
                this.data.clear();
            }
        });
        super._afterNew();
    }
    _handleDirties() {
        const geoJSON = this.get("geoJSON");
        let previous = this._prevSettings.geoJSON;
        if (previous && previous != geoJSON) {
            this._prevSettings.geoJSON = undefined;
            this._geoJSONparsed = false;
        }
        if (!this._geoJSONparsed) {
            this._parseGeoJSON();
            this._geoJSONparsed = true;
        }
    }
    _prepareChildren() {
        super._prepareChildren();
        if (this._valuesDirty) {
            this._handleDirties();
        }
        if (this.get("geoJSON") && (this.isDirty("geoJSON") || this.isDirty("include") || this.isDirty("exclude"))) {
            this._handleDirties();
            const chart = this.chart;
            const exclude = this.get("exclude");
            if (exclude) {
                if (chart) {
                    chart._centerLocation = null;
                }
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(exclude, (id)=>{
                    const dataItem = this.getDataItemById(id);
                    if (dataItem) {
                        this._excludeDataItem(dataItem);
                    }
                });
            }
            if (!exclude || exclude.length == 0) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(this._excluded, (dataItem)=>{
                    this._unexcludeDataItem(dataItem);
                });
                this._excluded = [];
            }
            const include = this.get("include");
            if (include) {
                if (chart) {
                    chart._centerLocation = null;
                }
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(this.dataItems, (dataItem)=>{
                    const id = dataItem.get("id");
                    if (id && include.indexOf(id) == -1) {
                        this._notIncludeDataItem(dataItem);
                    } else {
                        this._unNotIncludeDataItem(dataItem);
                    }
                });
            }
            if (!include) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(this._notIncluded, (dataItem)=>{
                    this._unNotIncludeDataItem(dataItem);
                });
                this._notIncluded = [];
            }
        }
    }
    _excludeDataItem(dataItem) {
        this._removeGeometry(dataItem.get("geometry"));
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.move(this._excluded, dataItem);
    }
    _unexcludeDataItem(dataItem) {
        this._addGeometry(dataItem.get("geometry"), this);
    }
    _notIncludeDataItem(dataItem) {
        this._removeGeometry(dataItem.get("geometry"));
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.move(this._notIncluded, dataItem);
    }
    _unNotIncludeDataItem(dataItem) {
        this._addGeometry(dataItem.get("geometry"), this);
    }
    checkInclude(id, includes, excludes) {
        if (includes) {
            if (includes.length == 0) {
                return false;
            } else {
                if (includes.indexOf(id) == -1) {
                    return false;
                }
            }
        }
        if (excludes && excludes.length > 0) {
            if (excludes.indexOf(id) != -1) {
                return false;
            }
        }
        return true;
    }
    _parseGeoJSON() {
        const geoJSON = this.get("geoJSON");
        if (geoJSON) {
            let features;
            if (geoJSON.type == "FeatureCollection") {
                features = geoJSON.features;
            } else if (geoJSON.type == "Feature") {
                features = [
                    geoJSON
                ];
            } else if ([
                "Point",
                "LineString",
                "Polygon",
                "MultiPoint",
                "MultiLineString",
                "MultiPolygon"
            ].indexOf(geoJSON.type) != -1) {
                features = [
                    {
                        geometry: geoJSON
                    }
                ];
            } else {
                console.log("nothing found in geoJSON");
            }
            const geodataNames = this.get("geodataNames");
            if (features) {
                const idField = this.get("idField", "id");
                for(let i = 0, len = features.length; i < len; i++){
                    let feature = features[i];
                    let geometry = feature.geometry;
                    if (geometry) {
                        let type = geometry.type;
                        let id = feature[idField];
                        if (geodataNames && geodataNames[id]) {
                            feature.properties.name = geodataNames[id];
                        }
                        if (this._types.indexOf(type) != -1) {
                            //if (!this.checkInclude(id, this.get("include"), this.get("exclude"))) {
                            //	continue;
                            //}
                            let dataItem;
                            if (id != null) {
                                // find data object in user-provided data
                                dataItem = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.find(this.dataItems, (value)=>{
                                    return value.get("id") == id;
                                });
                            }
                            let dataObject;
                            if (dataItem) {
                                dataObject = dataItem.dataContext;
                            }
                            // create one if not found
                            if (!dataItem) {
                                dataObject = {
                                    geometry: geometry,
                                    geometryType: type,
                                    madeFromGeoData: true
                                };
                                dataObject[idField] = id;
                                this.data.push(dataObject);
                            } else {
                                // if user-provided object doesn't have points data provided in any way:
                                if (!dataObject.geometry) {
                                    dataObject.geometry = geometry;
                                    dataObject.geometryType = type;
                                    dataItem.set("geometry", geometry);
                                    dataItem.set("geometryType", type);
                                    this.processDataItem(dataItem);
                                }
                            }
                            // copy properties data to datacontext
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.softCopyProperties(feature.properties, dataObject);
                        }
                    }
                }
            }
            const type = "geodataprocessed";
            if (this.events.isEnabled(type)) {
                this.events.dispatch(type, {
                    type: type,
                    target: this
                });
            }
        }
    }
    _placeBulletsContainer(_chart) {
        this.children.moveValue(this.bulletsContainer);
    }
    _removeBulletsContainer() {}
    /**
     * @ignore
     */ projection() {
        const chart = this.chart;
        if (chart) {
            return chart.get("projection");
        }
    }
    /**
     * @ignore
     */ geoPath() {
        const chart = this.chart;
        if (chart) {
            return chart.getPrivate("geoPath");
        }
    }
    _addGeometry(geometry, series) {
        if (geometry && series.get("affectsBounds", true)) {
            this._geometries.push(geometry);
            const chart = this.chart;
            if (chart) {
                chart.markDirtyGeometries();
            }
        }
    }
    _removeGeometry(geometry) {
        if (geometry) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.remove(this._geometries, geometry);
            const chart = this.chart;
            if (chart) {
                chart.markDirtyGeometries();
            }
        }
    }
    _dispose() {
        super._dispose();
        const chart = this.chart;
        if (chart) {
            chart.series.removeValue(this);
        }
    }
    _onDataClear() {
        super._onDataClear();
        this._geoJSONparsed = false;
        this._markDirtyKey("exclude");
    }
}
Object.defineProperty(MapSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "MapSeries"
});
Object.defineProperty(MapSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Series$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Series"].classNames.concat([
        MapSeries.className
    ])
}); //# sourceMappingURL=MapSeries.js.map

})()),
"[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapPointSeries.js [app-ssr] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {
"use strict";

__turbopack_esm__({
    "MapPointSeries": ()=>MapPointSeries
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapSeries.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Math.js [app-ssr] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
;
class MapPointSeries extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MapSeries"] {
    constructor(){
        super(...arguments);
        Object.defineProperty(this, "_types", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "Point",
                "MultiPoint"
            ]
        });
        Object.defineProperty(this, "_lineChangedDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _afterNew() {
        this.fields.push("polygonId", "lineId", "longitude", "latitude", "fixed");
        super._afterNew();
    }
    /**
     * @ignore
     */ markDirtyProjection() {
        this.markDirty();
    }
    /**
     * Forces a repaint of the element which relies on data.
     *
     * @since 5.0.21
     */ markDirtyValues(dataItem) {
        super.markDirtyValues();
        if (dataItem) {
            this._positionBullets(dataItem);
        }
    }
    processDataItem(dataItem) {
        super.processDataItem(dataItem);
        let geometry = dataItem.get("geometry");
        if (!geometry) {
            geometry = {
                type: "Point",
                coordinates: [
                    dataItem.get("longitude", 0),
                    dataItem.get("latitude", 0)
                ]
            };
            dataItem.set("geometry", geometry);
        } else {
            if (geometry.type == "Point") {
                const coordinates = geometry.coordinates;
                if (coordinates) {
                    dataItem.set("longitude", coordinates[0]);
                    dataItem.set("latitude", coordinates[1]);
                }
            } else if (geometry.type == "MultiPoint") {
                const coordinates = geometry.coordinates;
                if (coordinates && coordinates[0]) {
                    dataItem.set("longitude", coordinates[0][0]);
                    dataItem.set("latitude", coordinates[0][1]);
                }
            }
        }
        this._addGeometry(geometry, this);
    }
    _makeBullets(dataItem) {
        dataItem.bullets = [];
        this.bullets.each((bulletFunction)=>{
            const geometry = dataItem.get("geometry");
            if (geometry) {
                if (geometry.type == "Point") {
                    this._setBulletParent(this._makeBullet(dataItem, bulletFunction));
                } else if (geometry.type = "MultiPoint") {
                    let i = 0;
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(geometry.coordinates, ()=>{
                        this._setBulletParent(this._makeBullet(dataItem, bulletFunction, i));
                        i++;
                    });
                }
            }
        });
    }
    _setBulletParent(bullet) {
        if (bullet) {
            const sprite = bullet.get("sprite");
            const chart = this.chart;
            if (sprite && chart) {
                const dataItem = sprite.dataItem;
                if (dataItem) {
                    if (dataItem.get("fixed")) {
                        if (sprite.parent != chart.bulletsContainer) {
                            chart.bulletsContainer.children.moveValue(sprite);
                        }
                    } else {
                        if (sprite.parent != this.bulletsContainer) {
                            this.bulletsContainer.children.moveValue(sprite);
                        }
                    }
                }
            }
        }
    }
    _positionBullet(bullet) {
        const sprite = bullet.get("sprite");
        if (sprite) {
            const dataItem = sprite.dataItem;
            if (dataItem && dataItem.get("fixed")) {
                return;
            }
            const latitude = dataItem.get("latitude");
            const longitude = dataItem.get("longitude");
            const lineDataItem = dataItem.get("lineDataItem");
            const fixed = dataItem.get("fixed");
            const chart = this.chart;
            let line;
            if (lineDataItem) {
                line = lineDataItem.get("mapLine");
            } else {
                const lineId = dataItem.get("lineId");
                if (lineId && chart) {
                    chart.series.each((series)=>{
                        if (series.isType("MapLineSeries")) {
                            let lineDI = series.getDataItemById(lineId);
                            if (lineDI) {
                                dataItem.set("lineDataItem", lineDI);
                                line = lineDI.get("mapLine");
                            }
                        }
                    });
                }
            }
            if (this._lineChangedDp) {
                this._lineChangedDp.dispose();
            }
            if (line) {
                this._lineChangedDp = line.events.on("linechanged", ()=>{
                    this._positionBullets(dataItem);
                });
            }
            const polygonDataItem = dataItem.get("polygonDataItem");
            let polygon;
            if (polygonDataItem) {
                polygon = polygonDataItem.get("mapPolygon");
            } else {
                const polygonId = dataItem.get("polygonId");
                if (polygonId && chart) {
                    chart.series.each((series)=>{
                        if (series.isType("MapPolygonSeries")) {
                            let polygonDI = series.getDataItemById(polygonId);
                            if (polygonDI) {
                                dataItem.set("polygonDataItem", polygonDI);
                                polygon = polygonDI.get("mapPolygon");
                            }
                        }
                    });
                }
            }
            const positionOnLine = dataItem.get("positionOnLine");
            let coordinates;
            let angle;
            if (polygon) {
                let geoPoint = polygon.visualCentroid();
                coordinates = [
                    geoPoint.longitude,
                    geoPoint.latitude
                ];
                dataItem.setRaw("longitude", geoPoint.longitude);
                dataItem.setRaw("latitude", geoPoint.latitude);
            } else if (line && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isNumber(positionOnLine)) {
                let geoPoint = line.positionToGeoPoint(positionOnLine);
                coordinates = [
                    geoPoint.longitude,
                    geoPoint.latitude
                ];
                if (dataItem.get("autoRotate", bullet.get("autoRotate")) && chart) {
                    const geoPoint0 = line.positionToGeoPoint(positionOnLine - 0.002);
                    const geoPoint1 = line.positionToGeoPoint(positionOnLine + 0.002);
                    const point0 = chart.convert(geoPoint0);
                    const point1 = chart.convert(geoPoint1);
                    //dataItem.set("autoRotateAngle", $math.getAngle(point0, point1));
                    angle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.getAngle(point0, point1);
                }
                dataItem.setRaw("longitude", geoPoint.longitude);
                dataItem.setRaw("latitude", geoPoint.latitude);
            } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isNumber(longitude) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isNumber(latitude)) {
                coordinates = [
                    longitude,
                    latitude
                ];
            } else {
                const geometry = dataItem.get("geometry");
                if (geometry) {
                    if (geometry.type == "Point") {
                        this._positionBulletReal(bullet, geometry, geometry.coordinates, angle);
                    } else if (geometry.type == "MultiPoint") {
                        let index = bullet._index || 0;
                        coordinates = geometry.coordinates[index];
                    }
                }
            }
            if (!fixed && coordinates) {
                this._positionBulletReal(bullet, {
                    type: "Point",
                    coordinates: coordinates
                }, coordinates, angle);
            }
        }
    }
    _positionBulletReal(bullet, geometry, coordinates, angle) {
        const sprite = bullet.get("sprite");
        const chart = this.chart;
        if (chart) {
            const projection = chart.get("projection");
            const geoPath = chart.getPrivate("geoPath");
            const dataItem = sprite.dataItem;
            const xy = projection(coordinates);
            if (xy) {
                const point = {
                    x: xy[0],
                    y: xy[1]
                };
                sprite.setAll(point);
                dataItem.setRaw("point", point);
            }
            let visible = true;
            if (geoPath(geometry)) {
                if (this.get("clipFront")) {
                    visible = false;
                }
            } else {
                if (this.get("clipBack")) {
                    visible = false;
                }
            }
            sprite.setPrivate("visible", visible);
            dataItem.set("clipped", !visible);
            if (dataItem && angle != null && dataItem.get("autoRotate", bullet.get("autoRotate"))) {
                sprite.set("rotation", angle + dataItem.get("autoRotateAngle", bullet.get("autoRotateAngle", 0)));
            }
        }
    }
    /**
     * Centers the map to specific series' data item and zooms to the level
     * specified in the parameters.
     *
     * @param  dataItem   Map point
     * @param  zoomLevel  Zoom level
     * @param  rotate If it's true, the map will rotate so that this point would be in the center. Mostly usefull with geoOrthographic projection.
     */ zoomToDataItem(dataItem, zoomLevel, rotate) {
        const chart = this.chart;
        if (chart) {
            const longitude = dataItem.get("longitude", 0);
            const latitude = dataItem.get("latitude", 0);
            if (rotate) {
                return chart.zoomToGeoPoint({
                    longitude: longitude,
                    latitude: latitude
                }, zoomLevel, true, undefined, -longitude, -latitude);
            }
            return chart.zoomToGeoPoint({
                longitude: longitude,
                latitude: latitude
            }, zoomLevel, true);
        }
    }
    /**
     * Zooms the map in so that all points in the array are visible.
     *
     * @param   dataItems  An array of data items of points to zoom to
     * @param   rotate     Rotate the map so it is centered on the selected items
     * @return             Animation
     * @since 5.5.6
     */ zoomToDataItems(dataItems, rotate) {
        let left = null;
        let right = null;
        let top = null;
        let bottom = null;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(dataItems, (dataItem)=>{
            const longitude = dataItem.get("longitude", 0);
            const latitude = dataItem.get("latitude", 0);
            if (left == null || left > longitude) {
                left = longitude;
            }
            if (right == null || right < longitude) {
                right = longitude;
            }
            if (top == null || top < latitude) {
                top = latitude;
            }
            if (bottom == null || bottom > latitude) {
                bottom = latitude;
            }
        });
        if (left != null && right != null && top != null && bottom != null) {
            const chart = this.chart;
            if (chart) {
                if (rotate) {
                    return chart.zoomToGeoBounds({
                        left,
                        right,
                        top,
                        bottom
                    }, undefined, -(left + (right - left) / 2), -(top + (top - bottom) / 2));
                }
                return chart.zoomToGeoBounds({
                    left,
                    right,
                    top,
                    bottom
                });
            }
        }
    }
    /**
     * @ignore
     */ disposeDataItem(dataItem) {
        const chart = this.chart;
        if (chart) {
            chart.series.each((series)=>{
                if (series.isType("MapLineSeries")) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(series.dataItems, (di)=>{
                        const pointsToConnect = di.get("pointsToConnect");
                        if (pointsToConnect) {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(pointsToConnect, (point)=>{
                                if (point == dataItem) {
                                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.remove(pointsToConnect, point);
                                    series.markDirtyValues(di);
                                }
                            });
                        }
                    });
                }
            });
        }
        super.disposeDataItem(dataItem);
    }
    /**
     * @ignore
     */ _excludeDataItem(dataItem) {
        super._excludeDataItem(dataItem);
        const bullets = dataItem.bullets;
        if (bullets) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(bullets, (bullet)=>{
                const sprite = bullet.get("sprite");
                if (sprite) {
                    sprite.setPrivate("visible", false);
                }
            });
        }
    }
    /**
     * @ignore
     */ _unexcludeDataItem(dataItem) {
        super._unexcludeDataItem(dataItem);
        const bullets = dataItem.bullets;
        if (bullets) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(bullets, (bullet)=>{
                const sprite = bullet.get("sprite");
                if (sprite) {
                    sprite.setPrivate("visible", true);
                }
            });
        }
    }
    /**
     * @ignore
     */ _notIncludeDataItem(dataItem) {
        super._notIncludeDataItem(dataItem);
        const bullets = dataItem.bullets;
        if (bullets) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(bullets, (bullet)=>{
                const sprite = bullet.get("sprite");
                if (sprite) {
                    sprite.setPrivate("visible", false);
                }
            });
        }
    }
    /**
     * @ignore
     */ _unNotIncludeDataItem(dataItem) {
        super._unNotIncludeDataItem(dataItem);
        const bullets = dataItem.bullets;
        if (bullets) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(bullets, (bullet)=>{
                const sprite = bullet.get("sprite");
                if (sprite) {
                    sprite.setPrivate("visible", true);
                }
            });
        }
    }
}
Object.defineProperty(MapPointSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "MapPointSeries"
});
Object.defineProperty(MapPointSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MapSeries"].classNames.concat([
        MapPointSeries.className
    ])
}); //# sourceMappingURL=MapPointSeries.js.map

})()),
"[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/ClusteredPointSeries.js [app-ssr] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {
"use strict";

__turbopack_esm__({
    "ClusteredPointSeries": ()=>ClusteredPointSeries
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapPointSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapPointSeries.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Component$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/render/Component.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Container$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/render/Container.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Label$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/render/Label.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$hierarchy$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$facade$3e$__ = __turbopack_import__("[project]/node_modules/d3-hierarchy/src/index.js [app-ssr] (ecmascript) <facade>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Math.js [app-ssr] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
;
;
;
;
class ClusteredPointSeries extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapPointSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MapPointSeries"] {
    constructor(){
        super(...arguments);
        Object.defineProperty(this, "_dataItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.makeDataItem({})
        });
        Object.defineProperty(this, "_clusterIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_clusters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "clusteredDataItems", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_scatterIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_scatters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_packLayout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$hierarchy$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$facade$3e$__.pack()
        });
        Object.defineProperty(this, "_spiral", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    _afterNew() {
        this.fields.push("groupId");
        this._setRawDefault("groupIdField", "groupId");
        super._afterNew();
    }
    _updateChildren() {
        super._updateChildren();
        if (this.isDirty("scatterRadius")) {
            this._spiral = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.spiralPoints(0, 0, 300, 300, 0, 3, 3, 0, 0);
        }
        const groups = {};
        // distribute to groups
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(this.dataItems, (dataItem)=>{
            const groupId = dataItem.get("groupId", "_default");
            if (!groups[groupId]) {
                groups[groupId] = [];
            }
            groups[groupId].push(dataItem);
        });
        this._scatterIndex = -1;
        this._scatters = [];
        this._clusterIndex = -1;
        this._clusters = [];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(this.clusteredDataItems, (dataItem)=>{
            dataItem.setRaw("children", undefined);
        });
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(this.dataItems, (dataItem)=>{
            dataItem.setRaw("cluster", undefined);
        });
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(groups, (_key, group)=>{
            this._scatterGroup(group);
        });
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(groups, (_key, group)=>{
            this._clusterGroup(group);
        });
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(this.dataItems, (dataItem)=>{
            if (!dataItem.get("cluster")) {
                const bullets = dataItem.bullets;
                if (bullets) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(bullets, (bullet)=>{
                        const sprite = bullet.get("sprite");
                        if (sprite) {
                            sprite.set("forceHidden", false);
                        }
                    });
                }
            }
        });
    }
    /**
     * Zooms to the area so that all clustered data items of a cluster would be
     * visible.
     *
     * Pass in `true` as a second parameter to rotate that map so that the group
     * is in the center. This is especially useful in the maps that use
     * Orthographic (globe) projection.
     *
     * @param  dataItem  Group data item
     * @param  rotate    Rotate the map so that group is in the center?
     * @see {@link https://www.amcharts.com/docs/v5/charts/map-chart/clustered-point-series/#Drill_down} for more info
     */ zoomToCluster(dataItem, rotate) {
        this.zoomToDataItems(dataItem.get("children", []), rotate);
    }
    _clusterGroup(dataItems) {
        const chart = this.chart;
        if (chart && chart.get("zoomLevel", 1) >= chart.get("maxZoomLevel", 100) * this.get("stopClusterZoom", 0.95)) {
        // void
        } else {
            while(dataItems.length > 0){
                this._clusterIndex++;
                this._clusters[this._clusterIndex] = [];
                const cluster = this._clusters[this._clusterIndex];
                const dataItem = dataItems[0];
                cluster.push(dataItem);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.remove(dataItems, dataItem);
                this._clusterDataItem(dataItem, dataItems);
            }
        }
        let i = 0;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(this._clusters, (cluster)=>{
            let sumX = 0;
            let sumY = 0;
            let len = cluster.length;
            if (len > 1) {
                let clusteredDataItem = this.clusteredDataItems[i];
                if (!clusteredDataItem) {
                    clusteredDataItem = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Component$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataItem"](this, undefined, {});
                    const bulletMethod = this.get("clusteredBullet");
                    if (bulletMethod) {
                        const bullet = clusteredDataItem.set("bullet", bulletMethod(this._root, this, clusteredDataItem));
                        if (bullet) {
                            const sprite = bullet.get("sprite");
                            if (sprite) {
                                this.bulletsContainer.children.push(sprite);
                                sprite._setDataItem(clusteredDataItem);
                            }
                        }
                    }
                    this.clusteredDataItems.push(clusteredDataItem);
                }
                let groupId;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(cluster, (dataItem)=>{
                    dataItem.setRaw("cluster", clusteredDataItem);
                    const point = dataItem.get("point");
                    if (point) {
                        sumX += point.x;
                        sumY += point.y;
                    }
                    const bullets = dataItem.bullets;
                    if (bullets) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(bullets, (bullet)=>{
                            const sprite = bullet.get("sprite");
                            if (sprite) {
                                sprite.set("forceHidden", true);
                            }
                        });
                    }
                    groupId = dataItem.get("groupId");
                });
                let averageX = sumX / len;
                let averageY = sumY / len;
                clusteredDataItem.setRaw("children", cluster);
                clusteredDataItem.setRaw("groupId", groupId);
                const prevLen = clusteredDataItem.get("value");
                clusteredDataItem.setRaw("value", len);
                const bullet = clusteredDataItem.get("bullet");
                if (bullet) {
                    const sprite = bullet.get("sprite");
                    if (sprite) {
                        sprite.set("forceHidden", false);
                        sprite.setAll({
                            x: averageX,
                            y: averageY
                        });
                        if (prevLen != len) {
                            if (sprite instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Container$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Container"]) {
                                sprite.walkChildren((child)=>{
                                    if (child instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Label$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Label"]) {
                                        child.text.markDirtyText();
                                    }
                                });
                            }
                        }
                    }
                }
                i++;
            }
        });
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(this.clusteredDataItems, (dataItem)=>{
            let children = dataItem.get("children");
            if (!children || children.length == 0) {
                const bullet = dataItem.get("bullet");
                if (bullet) {
                    const sprite = bullet.get("sprite");
                    if (sprite) {
                        sprite.set("forceHidden", true);
                    }
                }
            }
        });
    }
    _onDataClear() {
        super._onDataClear();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(this.clusteredDataItems, (dataItem)=>{
            const bullet = dataItem.get("bullet");
            if (bullet) {
                const sprite = bullet.get("sprite");
                if (sprite) {
                    sprite.dispose();
                }
            }
        });
        this.clusteredDataItems = [];
    }
    _clusterDataItem(dataItem, dataItems) {
        const point = dataItem.get("point");
        if (point) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(dataItems, (di)=>{
                if (di && !di.get("clipped")) {
                    const diPoint = di.get("point");
                    if (diPoint) {
                        if (Math.hypot(diPoint.x - point.x, diPoint.y - point.y) < this.get("minDistance", 20)) {
                            const cluster = this._clusters[this._clusterIndex];
                            cluster.push(di);
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.remove(dataItems, di);
                            this._clusterDataItem(di, dataItems);
                        }
                    }
                }
            });
        }
    }
    _scatterGroup(dataItems) {
        const chart = this.chart;
        if (chart && chart.get("zoomLevel", 1) >= chart.get("maxZoomLevel", 100) * this.get("stopClusterZoom", 0.95)) {
            while(dataItems.length > 0){
                this._scatterIndex++;
                this._scatters[this._scatterIndex] = [];
                const scatter = this._scatters[this._scatterIndex];
                const dataItem = dataItems[0];
                scatter.push(dataItem);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.remove(dataItems, dataItem);
                this._scatterDataItem(dataItem, dataItems);
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(this._scatters, (scatter)=>{
                let len = scatter.length;
                if (len > 1) {
                    let previousCircles = [];
                    let s = 0;
                    let radius = this.get("scatterRadius", 8);
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(scatter, (dataItem)=>{
                        let spiralPoint = this._spiral[s];
                        let intersects = true;
                        if (previousCircles.length > 0) {
                            while(intersects){
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(previousCircles, (previousCircle)=>{
                                    intersects = false;
                                    while(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.circlesOverlap({
                                        x: spiralPoint.x,
                                        y: spiralPoint.y,
                                        radius: radius
                                    }, previousCircle)){
                                        s++;
                                        if (this._spiral[s] == undefined) {
                                            intersects = false;
                                        } else {
                                            intersects = true;
                                            spiralPoint = this._spiral[s];
                                        }
                                    }
                                });
                            }
                        }
                        const dx = spiralPoint.x;
                        const dy = spiralPoint.y;
                        previousCircles.push({
                            x: dx,
                            y: dy,
                            radius: radius
                        });
                        dataItem.set("dx", dx);
                        dataItem.set("dy", dy);
                        const bullets = dataItem.bullets;
                        if (bullets) {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(bullets, (bullet)=>{
                                const sprite = bullet.get("sprite");
                                if (sprite) {
                                    sprite.setAll({
                                        dx: dx,
                                        dy: dy
                                    });
                                }
                            });
                        }
                    });
                }
            });
        }
    }
    _scatterDataItem(dataItem, dataItems) {
        const point = dataItem.get("point");
        if (point) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(dataItems, (di)=>{
                if (di && !di.get("clipped")) {
                    const diPoint = di.get("point");
                    if (diPoint) {
                        if (Math.hypot(diPoint.x - point.x, diPoint.y - point.y) < this.get("scatterDistance", 5)) {
                            const scatter = this._scatters[this._scatterIndex];
                            scatter.push(di);
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.remove(dataItems, di);
                            this._scatterDataItem(di, dataItems);
                        }
                    }
                }
            });
        }
    }
}
Object.defineProperty(ClusteredPointSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "ClusteredPointSeries"
});
Object.defineProperty(ClusteredPointSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapPointSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MapPointSeries"].classNames.concat([
        ClusteredPointSeries.className
    ])
}); //# sourceMappingURL=ClusteredPointSeries.js.map

})()),
"[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapChartDefaultTheme.js [app-ssr] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {
"use strict";

__turbopack_esm__({
    "MapChartDefaultTheme": ()=>MapChartDefaultTheme
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$Theme$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/Theme.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$themes$2f$DefaultTheme$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$projection$2f$mercator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoMercator$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/src/projection/mercator.js [app-ssr] (ecmascript) <export default as geoMercator>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Ease$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js [app-ssr] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
class MapChartDefaultTheme extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$Theme$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Theme"] {
    setupDefaultRules() {
        super.setupDefaultRules();
        const ic = this._root.interfaceColors;
        const r = this.rule.bind(this);
        /**
         * ========================================================================
         * charts/map
         * ========================================================================
         */ r("MapChart").setAll({
            projection: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$projection$2f$mercator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoMercator$3e$__["geoMercator"])(),
            panX: "translateX",
            panY: "translateY",
            pinchZoom: true,
            zoomStep: 2,
            zoomLevel: 1,
            rotationX: 0,
            rotationY: 0,
            rotationZ: 0,
            maxZoomLevel: 32,
            minZoomLevel: 1,
            wheelY: "zoom",
            wheelX: "none",
            animationEasing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Ease$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.out(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Ease$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.cubic),
            wheelEasing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Ease$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.out(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Ease$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.cubic),
            wheelDuration: 0,
            wheelSensitivity: 1,
            maxPanOut: 0.4,
            centerMapOnZoomOut: true
        });
        {
            const rule = r("MapLine");
            rule.setAll({
                precision: 0.5,
                role: "figure"
            });
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$themes$2f$DefaultTheme$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setColor"])(rule, "stroke", ic, "grid");
        }
        r("MapPolygonSeries").setAll({
            affectsBounds: true
        });
        r("MapPointSeries").setAll({
            affectsBounds: false,
            clipFront: false,
            clipBack: true,
            autoScale: false
        });
        r("ClusteredPointSeries").setAll({
            minDistance: 20,
            scatterDistance: 3,
            scatterRadius: 8,
            stopClusterZoom: 0.95
        });
        r("MapLineSeries").setAll({
            affectsBounds: false
        });
        {
            const rule = r("MapPolygon");
            rule.setAll({
                precision: 0.5,
                isMeasured: false,
                role: "figure",
                fillOpacity: 1,
                position: "absolute",
                strokeWidth: 0.2,
                strokeOpacity: 1
            });
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$themes$2f$DefaultTheme$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setColor"])(rule, "fill", ic, "primaryButton");
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$themes$2f$DefaultTheme$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setColor"])(rule, "stroke", ic, "background");
        }
        r("Button", [
            "zoomtools",
            "home"
        ]).setAll({
            visible: false
        });
        /**
         * ------------------------------------------------------------------------
         * charts/map: Series
         * ------------------------------------------------------------------------
         */ r("GraticuleSeries").setAll({
            step: 10
        });
    }
} //# sourceMappingURL=MapChartDefaultTheme.js.map

})()),
"[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapLine.js [app-ssr] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {
"use strict";

__turbopack_esm__({
    "MapLine": ()=>MapLine
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Percent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Graphics$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$length$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoLength$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/src/length.js [app-ssr] (ecmascript) <export default as geoLength>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$interpolate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoInterpolate$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/src/interpolate.js [app-ssr] (ecmascript) <export default as geoInterpolate>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$distance$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoDistance$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/src/distance.js [app-ssr] (ecmascript) <export default as geoDistance>");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
class MapLine extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Graphics$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Graphics"] {
    constructor(){
        super(...arguments);
        Object.defineProperty(this, "_projectionDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this._projectionDirty || this.isDirty("geometry") || this.isDirty("precision")) {
            const geometry = this.get("geometry");
            if (geometry) {
                const series = this.getPrivate("series");
                if (series) {
                    const chart = series.chart;
                    if (chart) {
                        const projection = chart.get("projection");
                        let clipAngle = null;
                        if (projection && projection.clipAngle) {
                            clipAngle = projection.clipAngle();
                            projection.precision(this.get("precision", 0.5));
                        }
                        const dataItem = this.dataItem;
                        const geoPath = chart.getPrivate("geoPath");
                        if (geoPath && dataItem) {
                            this._clear = true;
                            if (dataItem.get("lineType", series.get("lineType")) == "straight") {
                                const geometry = this.get("geometry");
                                if (geometry) {
                                    let coordinates = geometry.coordinates;
                                    if (coordinates) {
                                        let segments;
                                        if (geometry.type == "LineString") {
                                            segments = [
                                                coordinates
                                            ];
                                        } else if (geometry.type == "MultiLineString") {
                                            segments = coordinates;
                                        }
                                        this.set("draw", (display)=>{
                                            for(let s = 0; s < segments.length; s++){
                                                let segment = segments[s];
                                                if (segment.length > 0) {
                                                    const gp0 = segment[0];
                                                    const p0 = chart.convert({
                                                        longitude: gp0[0],
                                                        latitude: gp0[1]
                                                    });
                                                    display.lineTo(p0.x, p0.y);
                                                    for(let p = 0; p < segment.length; p++){
                                                        const gp = segment[p];
                                                        const pn = chart.convert({
                                                            longitude: gp[0],
                                                            latitude: gp[1]
                                                        });
                                                        display.lineTo(pn.x, pn.y);
                                                    }
                                                }
                                            }
                                        });
                                    }
                                }
                            } else {
                                this.set("draw", (_display)=>{
                                    if (projection && series.get("clipBack") === false) {
                                        projection.clipAngle(180);
                                    }
                                    geoPath.context(this._display);
                                    geoPath(geometry);
                                    geoPath.context(null);
                                    if (projection && projection.clipAngle) {
                                        projection.clipAngle(clipAngle);
                                    }
                                });
                            }
                        }
                    }
                }
            }
            const type = "linechanged";
            if (this.events.isEnabled(type)) {
                this.events.dispatch(type, {
                    type: type,
                    target: this
                });
            }
        }
    }
    /**
     * @ignore
     */ markDirtyProjection() {
        this.markDirty();
        this._projectionDirty = true;
    }
    _clearDirty() {
        super._clearDirty();
        this._projectionDirty = false;
    }
    _getTooltipPoint() {
        let tooltipX = this.get("tooltipX");
        let tooltipY = this.get("tooltipY");
        let x = 0;
        let y = 0;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isNumber(tooltipX)) {
            x = tooltipX;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isNumber(tooltipY)) {
            y = tooltipY;
        }
        if (tooltipX instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Percent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Percent"]) {
            const geoPoint = this.positionToGeoPoint(tooltipX.value);
            const series = this.getPrivate("series");
            if (series) {
                const chart = series.chart;
                if (chart) {
                    const point = chart.convert(geoPoint);
                    x = point.x;
                    y = point.y;
                }
            }
        }
        return {
            x,
            y
        };
    }
    /**
     * Converts relative position along the line (0-1) into pixel coordinates.
     *
     * @param position  Position (0-1)
     * @return Coordinates
     */ positionToGeoPoint(position) {
        const geometry = this.get("geometry");
        const series = this.getPrivate("series");
        const chart = series.chart;
        const dataItem = this.dataItem;
        if (geometry && series && chart && dataItem) {
            const lineType = dataItem.get("lineType", series.get("lineType"));
            let totalDistance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$length$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoLength$3e$__["geoLength"])(geometry);
            let currentDistance = 0;
            let distanceAB;
            let positionA = 0;
            let positionB = 0;
            let pointA;
            let pointB;
            let coordinates = geometry.coordinates;
            if (coordinates) {
                let segments;
                if (geometry.type == "LineString") {
                    segments = [
                        coordinates
                    ];
                } else if (geometry.type == "MultiLineString") {
                    segments = coordinates;
                }
                for(let s = 0; s < segments.length; s++){
                    let segment = segments[s];
                    if (segment.length > 1) {
                        for(let p = 1; p < segment.length; p++){
                            pointA = segment[p - 1];
                            pointB = segment[p];
                            positionA = currentDistance / totalDistance;
                            distanceAB = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$distance$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoDistance$3e$__["geoDistance"])(pointA, pointB);
                            currentDistance += distanceAB;
                            positionB = currentDistance / totalDistance;
                            if (positionA <= position && positionB > position) {
                                s = segments.length;
                                break;
                            }
                        }
                    } else if (segment.length == 1) {
                        pointA = segment[0];
                        pointB = segment[0];
                        positionA = 0;
                        positionB = 1;
                    }
                }
                if (pointA && pointB) {
                    let positionAB = (position - positionA) / (positionB - positionA);
                    let location;
                    if (lineType == "straight") {
                        let p0 = chart.convert({
                            longitude: pointA[0],
                            latitude: pointA[1]
                        });
                        let p1 = chart.convert({
                            longitude: pointB[0],
                            latitude: pointB[1]
                        });
                        let x = p0.x + (p1.x - p0.x) * positionAB;
                        let y = p0.y + (p1.y - p0.y) * positionAB;
                        return chart.invert({
                            x: x,
                            y: y
                        });
                    } else {
                        location = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$interpolate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoInterpolate$3e$__["geoInterpolate"])(pointA, pointB)(positionAB);
                        return {
                            longitude: location[0],
                            latitude: location[1]
                        };
                    }
                }
            }
        }
        return {
            longitude: 0,
            latitude: 0
        };
    }
}
Object.defineProperty(MapLine, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "MapLine"
});
Object.defineProperty(MapLine, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Graphics$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Graphics"].classNames.concat([
        MapLine.className
    ])
}); //# sourceMappingURL=MapLine.js.map

})()),
"[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapLineSeries.js [app-ssr] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {
"use strict";

__turbopack_esm__({
    "MapLineSeries": ()=>MapLineSeries
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapSeries.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapLine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapLine.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$List$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/List.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Template$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Template.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Array.js [app-ssr] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
;
class MapLineSeries extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MapSeries"] {
    constructor(){
        super(...arguments);
        /**
         * A [[ListTemplate]] of all lines in series.
         *
         * `mapLines.template` can also be used to configure lines.
         *
         * @default new ListTemplate<MapLine>
         */ Object.defineProperty(this, "mapLines", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$List$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ListTemplate"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Template$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Template"].new({}), ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapLine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MapLine"]._new(this._root, {}, [
                    this.mapLines.template
                ]))
        });
        Object.defineProperty(this, "_types", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "LineString",
                "MultiLineString"
            ]
        });
    }
    _afterNew() {
        this.fields.push("lineType");
        this._setRawDefault("lineTypeField", "lineType");
        super._afterNew();
    }
    /**
     * @ignore
     */ makeMapLine(dataItem) {
        const mapLine = this.children.push(this.mapLines.make());
        mapLine._setDataItem(dataItem);
        this.mapLines.push(mapLine);
        return mapLine;
    }
    /**
     * @ignore
     */ markDirtyProjection() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(this.dataItems, (dataItem)=>{
            let mapLine = dataItem.get("mapLine");
            if (mapLine) {
                mapLine.markDirtyProjection();
            }
        });
    }
    _prepareChildren() {
        super._prepareChildren();
        if (this.isDirty("stroke")) {
            this.mapLines.template.set("stroke", this.get("stroke"));
        }
    }
    processDataItem(dataItem) {
        super.processDataItem(dataItem);
        let mapLine = dataItem.get("mapLine");
        if (!mapLine) {
            mapLine = this.makeMapLine(dataItem);
        }
        this._handlePointsToConnect(dataItem);
        dataItem.on("pointsToConnect", ()=>{
            this._handlePointsToConnect(dataItem);
        });
        dataItem.set("mapLine", mapLine);
        this._addGeometry(dataItem.get("geometry"), this);
        mapLine.setPrivate("series", this);
    }
    _handlePointsToConnect(dataItem) {
        const pointsToConnect = dataItem.get("pointsToConnect");
        if (pointsToConnect) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(pointsToConnect, (point)=>{
                point.on("geometry", ()=>{
                    this.markDirtyValues(dataItem);
                });
                point.on("longitude", ()=>{
                    this.markDirtyValues(dataItem);
                });
                point.on("latitude", ()=>{
                    this.markDirtyValues(dataItem);
                });
            });
            this.markDirtyValues(dataItem);
        }
    }
    /**
     * Forces a repaint of the element which relies on data.
     *
     * @since 5.0.21
     */ markDirtyValues(dataItem) {
        super.markDirtyValues();
        if (dataItem) {
            const mapLine = dataItem.get("mapLine");
            if (mapLine) {
                const pointsToConnect = dataItem.get("pointsToConnect");
                if (pointsToConnect) {
                    let coordinates = [];
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(pointsToConnect, (point)=>{
                        const longitude = point.get("longitude");
                        const latitude = point.get("latitude");
                        if (longitude != null && latitude != null) {
                            coordinates.push([
                                longitude,
                                latitude
                            ]);
                        } else {
                            const geometry = point.get("geometry");
                            if (geometry) {
                                const coords = geometry.coordinates;
                                if (coords) {
                                    coordinates.push([
                                        coords[0],
                                        coords[1]
                                    ]);
                                }
                            }
                        }
                    });
                    let geometry = {
                        type: "LineString",
                        coordinates: coordinates
                    };
                    dataItem.setRaw("geometry", geometry);
                    mapLine.set("geometry", geometry);
                } else {
                    mapLine.set("geometry", dataItem.get("geometry"));
                }
            }
        }
    }
    /**
     * @ignore
     */ disposeDataItem(dataItem) {
        super.disposeDataItem(dataItem);
        const mapLine = dataItem.get("mapLine");
        if (mapLine) {
            this.mapLines.removeValue(mapLine);
            mapLine.dispose();
        }
    }
    /**
     * @ignore
     */ _excludeDataItem(dataItem) {
        super._excludeDataItem(dataItem);
        const mapLine = dataItem.get("mapLine");
        if (mapLine) {
            mapLine.setPrivate("visible", false);
        }
    }
    /**
     * @ignore
     */ _unexcludeDataItem(dataItem) {
        super._unexcludeDataItem(dataItem);
        const mapLine = dataItem.get("mapLine");
        if (mapLine) {
            mapLine.setPrivate("visible", true);
        }
    }
    /**
     * @ignore
     */ _notIncludeDataItem(dataItem) {
        super._notIncludeDataItem(dataItem);
        const mapLine = dataItem.get("mapLine");
        if (mapLine) {
            mapLine.setPrivate("visible", false);
        }
    }
    /**
     * @ignore
     */ _unNotIncludeDataItem(dataItem) {
        super._unNotIncludeDataItem(dataItem);
        const mapLine = dataItem.get("mapLine");
        if (mapLine) {
            mapLine.setPrivate("visible", true);
        }
    }
}
Object.defineProperty(MapLineSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "MapLineSeries"
});
Object.defineProperty(MapLineSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MapSeries"].classNames.concat([
        MapLineSeries.className
    ])
}); //# sourceMappingURL=MapLineSeries.js.map

})()),
"[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/GraticuleSeries.js [app-ssr] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {
"use strict";

__turbopack_esm__({
    "GraticuleSeries": ()=>GraticuleSeries
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapLineSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapLineSeries.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$graticule$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoGraticule$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/src/graticule.js [app-ssr] (ecmascript) <export default as geoGraticule>");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
class GraticuleSeries extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapLineSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MapLineSeries"] {
    constructor(){
        super(...arguments);
        Object.defineProperty(this, "_dataItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.makeDataItem({})
        });
    }
    _afterNew() {
        super._afterNew();
        this.dataItems.push(this._dataItem);
        this._generate();
    }
    _updateChildren() {
        super._updateChildren();
        if (this.isDirty("step")) {
            this._generate();
        }
        if (this.isDirty("clipExtent")) {
            if (this.get("clipExtent")) {
                const chart = this.chart;
                if (chart) {
                    chart.events.on("geoboundschanged", ()=>{
                        this._generate();
                    });
                }
                this._generate();
            }
        }
    }
    _generate() {
        let graticule = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$graticule$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoGraticule$3e$__["geoGraticule"])();
        if (graticule) {
            if (this.get("clipExtent")) {
                const chart = this.chart;
                if (chart) {
                    const geoBounds = chart.geoBounds();
                    if (geoBounds) {
                        graticule.extent([
                            [
                                geoBounds.left,
                                geoBounds.bottom
                            ],
                            [
                                geoBounds.right,
                                geoBounds.top
                            ]
                        ]);
                    }
                }
            }
            const step = this.get("step", 10);
            graticule.stepMinor([
                360,
                360
            ]);
            graticule.stepMajor([
                step,
                step
            ]);
            this._dataItem.set("geometry", graticule());
        }
    }
}
Object.defineProperty(GraticuleSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "GraticuleSeries"
});
Object.defineProperty(GraticuleSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapLineSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MapLineSeries"].classNames.concat([
        GraticuleSeries.className
    ])
}); //# sourceMappingURL=GraticuleSeries.js.map

})()),
"[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapUtils.js [app-ssr] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {
"use strict";

__turbopack_esm__({
    "getGeoArea": ()=>getGeoArea,
    "getGeoBounds": ()=>getGeoBounds,
    "getGeoCentroid": ()=>getGeoCentroid,
    "getGeoCircle": ()=>getGeoCircle,
    "getGeoRectangle": ()=>getGeoRectangle,
    "normalizeGeoPoint": ()=>normalizeGeoPoint,
    "wrapAngleTo180": ()=>wrapAngleTo180
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Math.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$circle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoCircle$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/src/circle.js [app-ssr] (ecmascript) <export default as geoCircle>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$centroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoCentroid$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/src/centroid.js [app-ssr] (ecmascript) <export default as geoCentroid>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$bounds$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoBounds$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/src/bounds.js [app-ssr] (ecmascript) <export default as geoBounds>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$area$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoArea$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/src/area.js [app-ssr] (ecmascript) <export default as geoArea>");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
function getGeoCircle(geoPoint, radius) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$circle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoCircle$3e$__["geoCircle"])().center([
        geoPoint.longitude,
        geoPoint.latitude
    ]).radius(radius)();
}
function getGeoCentroid(geometry) {
    const centroid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$centroid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoCentroid$3e$__["geoCentroid"])(geometry);
    return {
        longitude: centroid[0],
        latitude: centroid[1]
    };
}
function getGeoArea(geometry) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$area$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoArea$3e$__["geoArea"])(geometry);
}
function getGeoBounds(geometry) {
    const bounds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$bounds$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoBounds$3e$__["geoBounds"])(geometry);
    if (bounds) {
        const geoBounds = {
            left: bounds[0][0],
            right: bounds[1][0],
            top: bounds[1][1],
            bottom: bounds[0][1]
        };
        if (geoBounds.right < geoBounds.left) {
            geoBounds.right = 180;
            geoBounds.left = -180;
        }
        return geoBounds;
    }
    return {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    };
}
function getGeoRectangle(north, east, south, west) {
    let multiPolygon = [];
    if (west <= -180) {
        west = -179.9999;
    }
    if (south <= -90) {
        south = -89.9999;
    }
    if (north >= 90) {
        north = 89.9999;
    }
    if (east >= 180) {
        east = 179.9999;
    }
    let stepLong = Math.min(90, (east - west) / Math.ceil((east - west) / 90));
    let stepLat = (north - south) / Math.ceil((north - south) / 90);
    for(let ln = west; ln < east; ln = ln + stepLong){
        let surface = [];
        multiPolygon.push([
            surface
        ]);
        if (ln + stepLong > east) {
            stepLong = east - ln;
        }
        for(let ll = ln; ll <= ln + stepLong; ll = ll + 5){
            surface.push([
                ll,
                north
            ]);
        }
        for(let lt = north; lt >= south; lt = lt - stepLat){
            surface.push([
                ln + stepLong,
                lt
            ]);
        }
        for(let ll = ln + stepLong; ll >= ln; ll = ll - 5){
            surface.push([
                ll,
                south
            ]);
        }
        for(let lt = south; lt <= north; lt = lt + stepLat){
            surface.push([
                ln,
                lt
            ]);
        }
    }
    return {
        type: "MultiPolygon",
        coordinates: multiPolygon
    };
}
function normalizeGeoPoint(geoPoint) {
    let longitude = wrapAngleTo180(geoPoint.longitude);
    let latitude = Math.asin(Math.sin(geoPoint.latitude * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.RADIANS)) * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.DEGREES;
    let latitude180 = wrapAngleTo180(geoPoint.latitude);
    if (Math.abs(latitude180) > 90) {
        longitude = wrapAngleTo180(longitude + 180);
    }
    geoPoint.longitude = longitude;
    geoPoint.latitude = latitude;
    return geoPoint;
}
function wrapAngleTo180(angle) {
    angle = angle % 360;
    if (angle > 180) {
        angle -= 360;
    }
    if (angle < -180) {
        angle += 360;
    }
    return angle;
} //# sourceMappingURL=MapUtils.js.map

})()),
"[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapChart.js [app-ssr] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {
"use strict";

__turbopack_esm__({
    "MapChart": ()=>MapChart
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapChartDefaultTheme$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapChartDefaultTheme.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$SerialChart$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/render/SerialChart.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$path$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoPath$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/src/path/index.js [app-ssr] (ecmascript) <export default as geoPath>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Color.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$Registry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/Registry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Math.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js [app-ssr] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
;
;
;
;
;
;
;
;
class MapChart extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$SerialChart$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SerialChart"] {
    constructor(){
        super(...arguments);
        Object.defineProperty(this, "_downTranslateX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downTranslateY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downRotationX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downRotationY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downRotationZ", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_pLat", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_pLon", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_movePoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_downZoomLevel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_doubleDownDistance", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_dirtyGeometries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_geometryColection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                type: "GeometryCollection",
                geometries: []
            }
        });
        Object.defineProperty(this, "_centerLocation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_za", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rxa", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rya", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_txa", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tya", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_mapBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                [
                    0,
                    0
                ],
                [
                    0,
                    0
                ]
            ]
        });
        Object.defineProperty(this, "_geoCentroid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                longitude: 0,
                latitude: 0
            }
        });
        Object.defineProperty(this, "_geoBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }
        });
        Object.defineProperty(this, "_prevGeoBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }
        });
        Object.defineProperty(this, "_dispatchBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_wheelDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_pw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_ph", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_mapFitted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_centerX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_centerY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    _makeGeoPath() {
        const projection = this.get("projection");
        const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$path$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoPath$3e$__["geoPath"])();
        path.projection(projection);
        this.setPrivateRaw("geoPath", path);
    }
    /**
     * Returns a geoPoint of the current zoom position.
     *
     * You can later use it to restore zoom position, e.g.: `chart.zoomToGeoPoint(geoPoint, zoomLevel, true)`.
     *
     * @since 5.2.19
     */ geoPoint() {
        return this.invert(this.seriesContainer.toGlobal({
            x: this.width() / 2,
            y: this.height() / 2
        }));
    }
    /**
     * Returns coordinates to geographical center of the map.
     */ geoCentroid() {
        return this._geoCentroid;
    }
    /**
     * Returns geographical bounds of the map.
     */ geoBounds() {
        return this._geoBounds;
    }
    _handleSetWheel() {
        const wheelX = this.get("wheelX");
        const wheelY = this.get("wheelY");
        const chartContainer = this.chartContainer;
        if (wheelX != "none" || wheelY != "none") {
            if (this._wheelDp) {
                this._wheelDp.dispose();
            }
            this._wheelDp = chartContainer.events.on("wheel", (event)=>{
                const wheelEasing = this.get("wheelEasing");
                const wheelSensitivity = this.get("wheelSensitivity", 1);
                const wheelDuration = this.get("wheelDuration", 0);
                const wheelEvent = event.originalEvent;
                // Ignore wheel event if it is happening on a non-chart element, e.g. if
                // some page element is over the chart.
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isLocalEvent(wheelEvent, this)) {
                    wheelEvent.preventDefault();
                } else {
                    return;
                }
                const point = chartContainer._display.toLocal(event.point);
                if (wheelY == "zoom") {
                    this._handleWheelZoom(wheelEvent.deltaY, point);
                } else if (wheelY == "rotateY") {
                    this._handleWheelRotateY(wheelEvent.deltaY / 5 * wheelSensitivity, wheelDuration, wheelEasing);
                } else if (wheelY == "rotateX") {
                    this._handleWheelRotateX(wheelEvent.deltaY / 5 * wheelSensitivity, wheelDuration, wheelEasing);
                }
                if (wheelX == "zoom") {
                    this._handleWheelZoom(wheelEvent.deltaX, point);
                } else if (wheelX == "rotateY") {
                    this._handleWheelRotateY(wheelEvent.deltaX / 5 * wheelSensitivity, wheelDuration, wheelEasing);
                } else if (wheelX == "rotateX") {
                    this._handleWheelRotateX(wheelEvent.deltaX / 5 * wheelSensitivity, wheelDuration, wheelEasing);
                }
            });
            this._disposers.push(this._wheelDp);
        } else {
            if (this._wheelDp) {
                this._wheelDp.dispose();
            }
        }
    }
    _prepareChildren() {
        super._prepareChildren();
        const projection = this.get("projection");
        const w = this.innerWidth();
        const h = this.innerHeight();
        const previousGeometries = this._geometryColection.geometries;
        if (this.isDirty("projection")) {
            this._makeGeoPath();
            this.markDirtyProjection();
            this._fitMap();
            projection.scale(this.getPrivate("mapScale") * this.get("zoomLevel", 1));
            if (projection.rotate) {
                projection.rotate([
                    this.get("rotationX", 0),
                    this.get("rotationY", 0),
                    this.get("rotationZ", 0)
                ]);
            }
            let prev = this._prevSettings.projection;
            if (prev && prev != projection) {
                let hw = w / 2;
                let hh = h / 2;
                if (prev.invert) {
                    let centerLocation = prev.invert([
                        hw,
                        hh
                    ]);
                    if (centerLocation) {
                        let xy = projection(centerLocation);
                        if (xy) {
                            let translate = projection.translate();
                            let xx = hw - (xy[0] - translate[0]);
                            let yy = hh - (xy[1] - translate[1]);
                            projection.translate([
                                xx,
                                yy
                            ]);
                            this.setRaw("translateX", xx);
                            this.setRaw("translateY", yy);
                        }
                    }
                }
            }
        }
        if (this.isDirty("wheelX") || this.isDirty("wheelY")) {
            this._handleSetWheel();
        }
        if (this._dirtyGeometries) {
            this._geometryColection.geometries = [];
            this.series.each((series)=>{
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.pushAll(this._geometryColection.geometries, series._geometries);
            });
            this._fitMap();
        }
        if (previousGeometries.length != 0 && (w != this._pw || h != this._ph || this._dirtyGeometries)) {
            if (w > 0 && h > 0) {
                let hw = w / 2;
                let hh = h / 2;
                projection.fitSize([
                    w,
                    h
                ], this._geometryColection);
                const newScale = projection.scale();
                this.setPrivateRaw("mapScale", newScale);
                projection.scale(newScale * this.get("zoomLevel", 1));
                if (this._centerLocation) {
                    let xy = projection(this._centerLocation);
                    if (xy) {
                        let translate = projection.translate();
                        let xx = hw - (xy[0] - translate[0]);
                        let yy = hh - (xy[1] - translate[1]);
                        projection.translate([
                            xx,
                            yy
                        ]);
                        this.setRaw("translateX", xx);
                        this.setRaw("translateY", yy);
                        this._centerX = translate[0];
                        this._centerY = translate[1];
                    }
                }
                this.markDirtyProjection();
                const geoPath = this.getPrivate("geoPath");
                this._mapBounds = geoPath.bounds(this._geometryColection);
            }
        }
        this._pw = w;
        this._ph = h;
        if (this.isDirty("zoomControl")) {
            const previous = this._prevSettings.zoomControl;
            const zoomControl = this.get("zoomControl");
            if (zoomControl !== previous) {
                this._disposeProperty("zoomControl");
                if (previous) {
                    previous.dispose();
                }
                if (zoomControl) {
                    zoomControl.setPrivate("chart", this);
                    this.children.push(zoomControl);
                }
                this.setRaw("zoomControl", zoomControl);
            }
        }
        if (this.isDirty("zoomLevel")) {
            projection.scale(this.getPrivate("mapScale") * this.get("zoomLevel", 1));
            this.markDirtyProjection();
            this.series.each((series)=>{
                if (series.isType("MapPointSeries")) {
                    if (series.get("autoScale")) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(series.dataItems, (dataItem)=>{
                            const bullets = dataItem.bullets;
                            if (bullets) {
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(bullets, (bullet)=>{
                                    const sprite = bullet.get("sprite");
                                    if (sprite) {
                                        sprite.set("scale", this.get("zoomLevel"));
                                    }
                                });
                            }
                        });
                    }
                }
            });
        }
        if (this.isDirty("translateX") || this.isDirty("translateY")) {
            projection.translate([
                this.get("translateX", this.width() / 2),
                this.get("translateY", this.height() / 2)
            ]);
            this.markDirtyProjection();
        }
        if (projection.rotate) {
            if (this.isDirty("rotationX") || this.isDirty("rotationY") || this.isDirty("rotationZ")) {
                projection.rotate([
                    this.get("rotationX", 0),
                    this.get("rotationY", 0),
                    this.get("rotationZ", 0)
                ]);
                this.markDirtyProjection();
            }
        }
        if (this.isDirty("pinchZoom") || this.get("panX") || this.get("panY")) {
            this._setUpTouch();
        }
    }
    _fitMap() {
        const projection = this.get("projection");
        let w = this.innerWidth();
        let h = this.innerHeight();
        if (w > 0 && h > 0) {
            projection.fitSize([
                w,
                h
            ], this._geometryColection);
            this.setPrivateRaw("mapScale", projection.scale());
            const translate = projection.translate();
            this.setRaw("translateX", translate[0]);
            this.setRaw("translateY", translate[1]);
            this._centerX = translate[0];
            this._centerY = translate[1];
            const geoPath = this.getPrivate("geoPath");
            this._mapBounds = geoPath.bounds(this._geometryColection);
            this._geoCentroid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.getGeoCentroid(this._geometryColection);
            const bounds = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.getGeoBounds(this._geometryColection);
            this._geoBounds = bounds;
            if (this._geometryColection.geometries.length > 0) {
                bounds.left = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.round(this._geoBounds.left, 3);
                bounds.right = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.round(this._geoBounds.right, 3);
                bounds.top = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.round(this._geoBounds.top, 3);
                bounds.bottom = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.round(this._geoBounds.bottom, 3);
                const prevGeoBounds = this._prevGeoBounds;
                if (prevGeoBounds && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.sameBounds(bounds, prevGeoBounds)) {
                    this._dispatchBounds = true;
                    this._prevGeoBounds = bounds;
                }
            }
            this._mapFitted = true;
        }
    }
    /**
     * Returns geographical coordinates for calculated or manual center of the
     * map.
     */ homeGeoPoint() {
        let homeGeoPoint = this.get("homeGeoPoint");
        if (!homeGeoPoint) {
            const geoPath = this.getPrivate("geoPath");
            const bounds = geoPath.bounds(this._geometryColection);
            const left = bounds[0][0];
            const top = bounds[0][1];
            const right = bounds[1][0];
            const bottom = bounds[1][1];
            homeGeoPoint = this.invert({
                x: left + (right - left) / 2,
                y: top + (bottom - top) / 2
            });
        }
        return homeGeoPoint;
    }
    /**
     * Repositions the map to the "home" zoom level and center coordinates.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/map-chart/map-pan-zoom/#Resetting_position_level} for more info
     * @param  duration  Animation duration in milliseconds
     */ goHome(duration) {
        this.zoomToGeoPoint(this.homeGeoPoint(), this.get("homeZoomLevel", 1), true, duration, this.get("homeRotationX"), this.get("homeRotationY"));
    }
    _updateChildren() {
        const projection = this.get("projection");
        if (projection.invert) {
            let w = this.innerWidth();
            let h = this.innerHeight();
            if (w > 0 && h > 0) {
                this._centerLocation = projection.invert([
                    this.innerWidth() / 2,
                    this.innerHeight() / 2
                ]);
            }
        }
        super._updateChildren();
    }
    _afterChanged() {
        super._afterChanged();
        if (this._dispatchBounds) {
            this._dispatchBounds = false;
            const type = "geoboundschanged";
            if (this.events.isEnabled(type)) {
                this.events.dispatch(type, {
                    type: type,
                    target: this
                });
            }
        }
    }
    _setUpTouch() {
        if (!this.chartContainer._display.cancelTouch) {
            this.chartContainer._display.cancelTouch = this.get("pinchZoom") || this.get("panX") || this.get("panY") ? true : false;
        }
    }
    /**
     * @ignore
     */ markDirtyGeometries() {
        this._dirtyGeometries = true;
        this.markDirty();
    }
    /**
     * @ignore
     */ markDirtyProjection() {
        this.series.each((series)=>{
            series.markDirtyProjection();
        });
    }
    _afterNew() {
        this._defaultThemes.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapChartDefaultTheme$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MapChartDefaultTheme"].new(this._root));
        this._settings.themeTags = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.mergeTags(this._settings.themeTags, [
            "map"
        ]);
        this.children.push(this.bulletsContainer);
        super._afterNew();
        this._makeGeoPath();
        this.chartContainer.children.push(this.seriesContainer);
        if (this.get("translateX") == null) {
            this.set("translateX", this.width() / 2);
        }
        if (this.get("translateY") == null) {
            this.set("translateY", this.height() / 2);
        }
        // Setting trasnparent background so that full body of the plot container
        // is interactive
        this.chartContainer.set("interactive", true);
        this.chartContainer.set("interactiveChildren", false);
        this.chartContainer.set("background", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"].new(this._root, {
            themeTags: [
                "map",
                "background"
            ],
            fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].fromHex(0x000000),
            fillOpacity: 0
        }));
        this._disposers.push(this.chartContainer.events.on("pointerdown", (event)=>{
            this._handleChartDown(event);
        }));
        this._disposers.push(this.chartContainer.events.on("globalpointerup", (event)=>{
            this._handleChartUp(event);
        }));
        this._disposers.push(this.chartContainer.events.on("globalpointermove", (event)=>{
            this._handleChartMove(event);
        }));
        let license = false;
        for(let i = 0; i < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$Registry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registry"].licenses.length; i++){
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$Registry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registry"].licenses[i].match(/^AM5M.{5,}/i)) {
                license = true;
            }
        }
        if (!license) {
            this._root._showBranding();
        } else {
            this._root._licenseApplied();
        }
        this._setUpTouch();
    }
    _handleChartDown(event) {
        this._downZoomLevel = this.get("zoomLevel", 1);
        const downPoints = this.chartContainer._downPoints;
        let count = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.keys(downPoints).length;
        if (count == 1) {
            // workaround to solve a problem when events are added to some children of chart container (rotation stops working)
            let downPoint = downPoints[1];
            if (!downPoint) {
                downPoint = downPoints[0];
            }
            if (downPoint && downPoint.x == event.point.x && downPoint.y == event.point.y) {
                count = 0;
            }
        }
        if (count > 0) {
            this._downTranslateX = this.get("translateX");
            this._downTranslateY = this.get("translateY");
            this._downRotationX = this.get("rotationX");
            this._downRotationY = this.get("rotationY");
            this._downRotationZ = this.get("rotationZ");
            const downId = this.chartContainer._getDownPointId();
            if (downId) {
                let movePoint = this._movePoints[downId];
                if (movePoint) {
                    this.chartContainer._downPoints[downId] = movePoint;
                }
            }
        } else if (count == 0) {
            let bg = this.chartContainer.get("background");
            if (bg) {
                bg.events.enableType("click");
            }
            if (this.get("panX") || this.get("panY")) {
                if (this._za) {
                    this._za.stop();
                }
                if (this._txa) {
                    this._txa.stop();
                }
                if (this._tya) {
                    this._tya.stop();
                }
                if (this._rxa) {
                    this._rxa.stop();
                }
                if (this._rya) {
                    this._rya.stop();
                }
                const downPoint = this.chartContainer._display.toLocal(event.point);
                this._downTranslateX = this.get("translateX");
                this._downTranslateY = this.get("translateY");
                this._downRotationX = this.get("rotationX");
                this._downRotationY = this.get("rotationY");
                this._downRotationZ = this.get("rotationZ");
                let projection = this.get("projection");
                if (projection.invert) {
                    let l0 = projection.invert([
                        downPoint.x,
                        downPoint.y
                    ]);
                    let l1 = projection.invert([
                        downPoint.x + 1,
                        downPoint.y + 1
                    ]);
                    if (l0 && l1) {
                        this._pLon = Math.abs(l1[0] - l0[0]);
                        this._pLat = Math.abs(l1[1] - l0[1]);
                    }
                }
            }
        }
    }
    /**
     * Converts screen coordinates (X and Y) within chart to latitude and
     * longitude.
     *
     * @param  point  Screen coordinates
     * @return        Geographical coordinates
     */ invert(point) {
        let projection = this.get("projection");
        if (projection.invert) {
            const ll = projection.invert([
                point.x,
                point.y
            ]);
            if (ll) {
                return {
                    longitude: ll[0],
                    latitude: ll[1]
                };
            }
        }
        return {
            longitude: 0,
            latitude: 0
        };
    }
    /**
     * Converts latitude/longitude to screen coordinates (X and Y).
     *
     * @param  point  Geographical coordinates
     * @param  rotationX  X rotation of a map if different from current
     * @param  rotationY  Y rotation of a map if different from current
     *
     * @return Screen coordinates
     */ convert(point, rotationX, rotationY) {
        let projection = this.get("projection");
        let xy;
        if (!projection.rotate) {
            rotationX = undefined;
            rotationY = undefined;
        }
        if (rotationX != null || rotationY != null) {
            if (rotationX == null) {
                rotationX = 0;
            }
            if (rotationY == null) {
                rotationY = 0;
            }
            let rotation = projection.rotate();
            projection.rotate([
                rotationX,
                rotationY,
                0
            ]);
            xy = projection([
                point.longitude,
                point.latitude
            ]);
            projection.rotate(rotation);
        } else {
            xy = projection([
                point.longitude,
                point.latitude
            ]);
        }
        if (xy) {
            return {
                x: xy[0],
                y: xy[1]
            };
        }
        return {
            x: 0,
            y: 0
        };
    }
    _handleChartUp(_event) {
        this.chartContainer._downPoints = {};
    }
    _handlePinch() {
        const chartContainer = this.chartContainer;
        let i = 0;
        let downPoints = [];
        let movePoints = [];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(chartContainer._downPoints, (k, point)=>{
            downPoints[i] = point;
            let movePoint = this._movePoints[k];
            if (movePoint) {
                movePoints[i] = movePoint;
            }
            i++;
        });
        if (downPoints.length > 1 && movePoints.length > 1) {
            const display = chartContainer._display;
            let downPoint0 = downPoints[0];
            let downPoint1 = downPoints[1];
            let movePoint0 = movePoints[0];
            let movePoint1 = movePoints[1];
            if (downPoint0 && downPoint1 && movePoint0 && movePoint1) {
                downPoint0 = display.toLocal(downPoint0);
                downPoint1 = display.toLocal(downPoint1);
                movePoint0 = display.toLocal(movePoint0);
                movePoint1 = display.toLocal(movePoint1);
                let initialDistance = Math.hypot(downPoint1.x - downPoint0.x, downPoint1.y - downPoint0.y);
                let currentDistance = Math.hypot(movePoint1.x - movePoint0.x, movePoint1.y - movePoint0.y);
                let level = currentDistance / initialDistance * this._downZoomLevel;
                level = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.fitToRange(level, this.get("minZoomLevel", 1), this.get("maxZoomLevel", 32));
                let moveCenter = {
                    x: movePoint0.x + (movePoint1.x - movePoint0.x) / 2,
                    y: movePoint0.y + (movePoint1.y - movePoint0.y) / 2
                };
                let downCenter = {
                    x: downPoint0.x + (downPoint1.x - downPoint0.x) / 2,
                    y: downPoint0.y + (downPoint1.y - downPoint0.y) / 2
                };
                let tx = this._downTranslateX || 0;
                let ty = this._downTranslateY || 0;
                let zoomLevel = this._downZoomLevel;
                let xx = moveCenter.x - (-tx + downCenter.x) / zoomLevel * level;
                let yy = moveCenter.y - (-ty + downCenter.y) / zoomLevel * level;
                this.set("zoomLevel", level);
                this.set("translateX", xx);
                this.set("translateY", yy);
            }
        }
    }
    _handleChartMove(event) {
        const chartContainer = this.chartContainer;
        let downPoint = chartContainer._getDownPoint();
        const downPointId = chartContainer._getDownPointId();
        const originalEvent = event.originalEvent;
        const pointerId = originalEvent.pointerId;
        if (this.get("pinchZoom")) {
            if (pointerId) {
                this._movePoints[pointerId] = event.point;
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.keys(chartContainer._downPoints).length > 1) {
                    this._handlePinch();
                    return;
                }
            }
        }
        if (downPointId && pointerId && pointerId != downPointId) {
            return;
        } else {
            if (downPoint) {
                const panX = this.get("panX");
                const panY = this.get("panY");
                if (panX != "none" || panY != "none") {
                    const display = chartContainer._display;
                    let local = display.toLocal(event.point);
                    downPoint = display.toLocal(downPoint);
                    let x = this._downTranslateX;
                    let y = this._downTranslateY;
                    if (Math.hypot(downPoint.x - local.x, downPoint.y - local.y) > 5) {
                        let bg = chartContainer.get("background");
                        if (bg) {
                            bg.events.disableType("click");
                        }
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isNumber(x) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isNumber(y)) {
                            let projection = this.get("projection");
                            const zoomLevel = this.get("zoomLevel", 1);
                            const maxPanOut = this.get("maxPanOut", 0.4);
                            const bounds = this._mapBounds;
                            const w = this.width();
                            const h = this.height();
                            const ww = bounds[1][0] - bounds[0][0];
                            const hh = bounds[1][1] - bounds[0][1];
                            if (panX == "translateX") {
                                x += local.x - downPoint.x;
                                const cx = w / 2 - (w / 2 - this._centerX) * zoomLevel;
                                x = Math.min(x, cx + ww * maxPanOut * zoomLevel);
                                x = Math.max(x, cx - ww * maxPanOut * zoomLevel);
                            }
                            if (panY == "translateY") {
                                y += local.y - downPoint.y;
                                const cy = h / 2 - (h / 2 - this._centerY) * zoomLevel;
                                y = Math.min(y, cy + hh * maxPanOut * zoomLevel);
                                y = Math.max(y, cy - hh * maxPanOut * zoomLevel);
                            }
                            this.set("translateX", x);
                            this.set("translateY", y);
                            if (projection.invert) {
                                let downLocation = projection.invert([
                                    downPoint.x,
                                    downPoint.y
                                ]);
                                if (location && downLocation) {
                                    if (panX == "rotateX") {
                                        this.set("rotationX", this._downRotationX - (downPoint.x - local.x) * this._pLon);
                                    }
                                    if (panY == "rotateY") {
                                        this.set("rotationY", this._downRotationY + (downPoint.y - local.y) * this._pLat);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    _handleWheelRotateY(delta, duration, easing) {
        this._rya = this.animate({
            key: "rotationY",
            to: this.get("rotationY", 0) - delta,
            duration: duration,
            easing: easing
        });
    }
    _handleWheelRotateX(delta, duration, easing) {
        this._rxa = this.animate({
            key: "rotationX",
            to: this.get("rotationX", 0) - delta,
            duration: duration,
            easing: easing
        });
    }
    _handleWheelZoom(delta, point) {
        let step = this.get("zoomStep", 2);
        let zoomLevel = this.get("zoomLevel", 1);
        let newZoomLevel = zoomLevel;
        if (delta > 0) {
            newZoomLevel = zoomLevel / step;
        } else if (delta < 0) {
            newZoomLevel = zoomLevel * step;
        }
        if (newZoomLevel != zoomLevel) {
            this.zoomToPoint(point, newZoomLevel);
        }
    }
    /**
     * Zoom the map to geographical bounds.
     *
     * @param  geoBounds  Bounds
     * @param  duration   Animation duration in milliseconds
     * @param  rotationX  X rotation of a map at the end of zoom
     * @param  rotationY  Y rotation of a map at the end of zoom
     */ zoomToGeoBounds(geoBounds, duration, rotationX, rotationY) {
        if (geoBounds.right < geoBounds.left) {
            geoBounds.right = 180;
            geoBounds.left = -180;
        }
        const geoPath = this.getPrivate("geoPath");
        const mapBounds = geoPath.bounds(this._geometryColection);
        let p0 = this.convert({
            longitude: geoBounds.left,
            latitude: geoBounds.top
        }, rotationX, rotationY);
        let p1 = this.convert({
            longitude: geoBounds.right,
            latitude: geoBounds.bottom
        }, rotationX, rotationY);
        if (p0.y < mapBounds[0][1]) {
            p0.y = mapBounds[0][1];
        }
        if (p1.y > mapBounds[1][1]) {
            p1.y = mapBounds[1][1];
        }
        let zl = this.get("zoomLevel", 1);
        let bounds = {
            left: p0.x,
            right: p1.x,
            top: p0.y,
            bottom: p1.y
        };
        let seriesContainer = this.seriesContainer;
        let zoomLevel = .9 * Math.min(seriesContainer.innerWidth() / (bounds.right - bounds.left) * zl, seriesContainer.innerHeight() / (bounds.bottom - bounds.top) * zl);
        let x = bounds.left + (bounds.right - bounds.left) / 2;
        let y = bounds.top + (bounds.bottom - bounds.top) / 2;
        let geoPoint = this.invert({
            x,
            y
        });
        if (rotationX != null || rotationY != null) {
            this.rotate(rotationX, rotationY);
        }
        return this.zoomToGeoPoint(geoPoint, zoomLevel, true, duration);
    }
    /**
     * Zooms the map to specific screen point.
     *
     * @param  point    Point
     * @param  level    Zoom level
     * @param  center   Center the map
     * @param  duration Duration of the animation in milliseconds
     */ zoomToPoint(point, level, center, duration) {
        if (level) {
            level = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.fitToRange(level, this.get("minZoomLevel", 1), this.get("maxZoomLevel", 32));
        }
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isNumber(duration)) {
            duration = this.get("animationDuration", 0);
        }
        const easing = this.get("animationEasing");
        const zoomLevel = this.get("zoomLevel", 1);
        if (this.get("centerMapOnZoomOut") && level == this.get("homeZoomLevel", 1)) {
            point = this.convert(this.homeGeoPoint(), this.get("homeRotationX"), this.get("homeRotationY"));
            center = true;
        }
        let x = point.x;
        let y = point.y;
        let tx = this.get("translateX", 0);
        let ty = this.get("translateY", 0);
        let cx = x;
        let cy = y;
        if (center) {
            cx = this.width() / 2;
            cy = this.height() / 2;
        }
        let xx = cx - (x - tx) / zoomLevel * level;
        let yy = cy - (y - ty) / zoomLevel * level;
        this._txa = this.animate({
            key: "translateX",
            to: xx,
            duration: duration,
            easing: easing
        });
        this._tya = this.animate({
            key: "translateY",
            to: yy,
            duration: duration,
            easing: easing
        });
        this._za = this.animate({
            key: "zoomLevel",
            to: level,
            duration: duration,
            easing: easing
        });
        if (zoomLevel != level) {
            this._root.readerAlert(this._t("Zoom level changed to %1", this._root.locale, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.numberToString(level)));
        }
        return this._za;
    }
    /**
     * Zooms the map to specific geographical point.
     *
     * @param  geoPoint  Point
     * @param  level     Zoom level
     * @param  center    Center the map
     * @param  duration  Duration of the animation in milliseconds
     * @param  rotationX  X rotation of a map at the end of zoom
     * @param  rotationY  Y rotation of a map at the end of zoom
     *
     */ zoomToGeoPoint(geoPoint, level, center, duration, rotationX, rotationY) {
        let xy = this.convert(geoPoint, rotationX, rotationY);
        if (rotationX != null || rotationY != null) {
            this.rotate(rotationX, rotationY, duration);
        }
        if (xy) {
            return this.zoomToPoint(xy, level, center, duration);
        }
    }
    rotate(rotationX, rotationY, duration) {
        const projection = this.get("projection");
        if (!projection.rotate) {} else {
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isNumber(duration)) {
                duration = this.get("animationDuration", 0);
            }
            const easing = this.get("animationEasing");
            if (rotationX != null) {
                this.animate({
                    key: "rotationX",
                    to: rotationX,
                    duration: duration,
                    easing: easing
                });
            }
            if (rotationY != null) {
                this.animate({
                    key: "rotationY",
                    to: rotationY,
                    duration: duration,
                    easing: easing
                });
            }
        }
    }
    /**
     * Zooms the map in.
     */ zoomIn() {
        return this.zoomToPoint({
            x: this.width() / 2,
            y: this.height() / 2
        }, this.get("zoomLevel", 1) * this.get("zoomStep", 2));
    }
    /**
     * Zooms the map out.
     */ zoomOut() {
        return this.zoomToPoint({
            x: this.width() / 2,
            y: this.height() / 2
        }, this.get("zoomLevel", 1) / this.get("zoomStep", 2));
    }
    _clearDirty() {
        super._clearDirty();
        this._dirtyGeometries = false;
        this._mapFitted = false;
    }
    /**
     * Returns area of a mapPolygon in square pixels.
     */ getArea(dataItem) {
        const geoPath = this.getPrivate("geoPath");
        const geometry = dataItem.get("geometry");
        if (geometry) {
            return geoPath.area(geometry);
        }
        return 0;
    }
}
Object.defineProperty(MapChart, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "MapChart"
});
Object.defineProperty(MapChart, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$SerialChart$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SerialChart"].classNames.concat([
        MapChart.className
    ])
}); //# sourceMappingURL=MapChart.js.map

})()),
"[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapPolygon.js [app-ssr] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {
"use strict";

__turbopack_esm__({
    "MapPolygon": ()=>MapPolygon
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Graphics$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polylabel$2f$polylabel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/polylabel/polylabel.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$area$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoArea$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/src/area.js [app-ssr] (ecmascript) <export default as geoArea>");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
class MapPolygon extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Graphics$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Graphics"] {
    constructor(){
        super(...arguments);
        Object.defineProperty(this, "_projectionDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * A [[MapPolygonSeries]] polygon belongs to.
         */ Object.defineProperty(this, "series", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this._projectionDirty || this.isDirty("geometry") || this.isDirty("precision")) {
            const geometry = this.get("geometry");
            if (geometry) {
                const series = this.series;
                if (series) {
                    const projection = series.projection();
                    if (projection) {
                        projection.precision(this.get("precision", 0.5));
                    }
                    const geoPath = series.geoPath();
                    if (geoPath) {
                        this._clear = true;
                        this.set("draw", (_display)=>{
                            geoPath.context(this._display);
                            geoPath(geometry);
                            geoPath.context(null);
                        });
                        if (this.isHover()) {
                            this.showTooltip();
                        }
                    }
                }
            }
        }
    }
    /**
     * @ignore
     */ markDirtyProjection() {
        this.markDirty();
        this._projectionDirty = true;
    }
    _clearDirty() {
        super._clearDirty();
        this._projectionDirty = false;
    }
    /**
     * Returns latitude/longitude of the geometrical center of the polygon.
     *
     * @return Center
     */ geoCentroid() {
        const geometry = this.get("geometry");
        if (geometry) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.getGeoCentroid(geometry);
        } else {
            return {
                latitude: 0,
                longitude: 0
            };
        }
    }
    /**
     * Returns latitude/longitude of the visual center of the polygon.
     *
     * @return Center
     */ visualCentroid() {
        let biggestArea = 0;
        let coordinates = [];
        const geometry = this.get("geometry");
        if (geometry) {
            if (geometry.type == "Polygon") {
                coordinates = geometry.coordinates;
            } else if (geometry.type == "MultiPolygon") {
                for(let i = 0; i < geometry.coordinates.length; i++){
                    let coords = geometry.coordinates[i];
                    let area = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$area$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoArea$3e$__["geoArea"])({
                        type: "Polygon",
                        coordinates: coords
                    });
                    if (area > biggestArea) {
                        coordinates = coords;
                        biggestArea = area;
                    }
                }
            }
            if (coordinates) {
                let center = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polylabel$2f$polylabel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(coordinates);
                return {
                    longitude: center[0],
                    latitude: center[1]
                };
            }
        }
        return {
            longitude: 0,
            latitude: 0
        };
    }
    _getTooltipPoint() {
        const series = this.series;
        if (series) {
            const projection = series.projection();
            if (projection) {
                const geoPoint = this.visualCentroid();
                const xy = projection([
                    geoPoint.longitude,
                    geoPoint.latitude
                ]);
                if (xy) {
                    return {
                        x: xy[0],
                        y: xy[1]
                    };
                }
            }
        }
        return {
            x: 0,
            y: 0
        };
    }
}
Object.defineProperty(MapPolygon, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "MapPolygon"
});
Object.defineProperty(MapPolygon, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$Graphics$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Graphics"].classNames.concat([
        MapPolygon.className
    ])
}); //# sourceMappingURL=MapPolygon.js.map

})()),
"[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapPolygonSeries.js [app-ssr] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {
"use strict";

__turbopack_esm__({
    "MapPolygonSeries": ()=>MapPolygonSeries
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapSeries.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapPolygon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapPolygon.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Template$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Template.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$List$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/List.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/util/Array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/MapUtils.js [app-ssr] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
;
;
class MapPolygonSeries extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MapSeries"] {
    constructor(){
        super(...arguments);
        /**
         * A [[ListTemplate]] of all polygons in series.
         *
         * `mapPolygons.template` can also be used to configure polygons.
         *
         * @default new ListTemplate<MapPolygon>
         */ Object.defineProperty(this, "mapPolygons", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$List$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ListTemplate"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Template$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Template"].new({}), ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapPolygon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MapPolygon"]._new(this._root, {}, [
                    this.mapPolygons.template
                ]))
        });
        Object.defineProperty(this, "_types", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "Polygon",
                "MultiPolygon"
            ]
        });
    }
    /**
     * @ignore
     */ makeMapPolygon(dataItem) {
        const mapPolygon = this.children.push(this.mapPolygons.make());
        mapPolygon._setDataItem(dataItem);
        this.mapPolygons.push(mapPolygon);
        return mapPolygon;
    }
    /**
     * @ignore
     */ markDirtyProjection() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(this.dataItems, (dataItem)=>{
            let mapPolygon = dataItem.get("mapPolygon");
            if (mapPolygon) {
                mapPolygon.markDirtyProjection();
            }
        });
    }
    _prepareChildren() {
        super._prepareChildren();
        if (this.isDirty("fill")) {
            this.mapPolygons.template.set("fill", this.get("fill"));
        }
        if (this.isDirty("stroke")) {
            this.mapPolygons.template.set("stroke", this.get("stroke"));
        }
    }
    processDataItem(dataItem) {
        super.processDataItem(dataItem);
        let mapPolygon = dataItem.get("mapPolygon");
        if (!mapPolygon) {
            mapPolygon = this.makeMapPolygon(dataItem);
        }
        dataItem.set("mapPolygon", mapPolygon);
        let geometry = dataItem.get("geometry");
        if (geometry) {
            if (this.get("reverseGeodata")) {
                const coordinates = geometry.coordinates;
                if (coordinates) {
                    for(let x = 0; x < geometry.coordinates.length; x++){
                        if (geometry.type == "MultiPolygon") {
                            for(let y = 0; y < geometry.coordinates[x].length; y++){
                                geometry.coordinates[x][y].reverse();
                            }
                        } else {
                            geometry.coordinates[x].reverse();
                        }
                    }
                }
            }
            mapPolygon.set("geometry", geometry);
        }
        mapPolygon.series = this;
        this._addGeometry(dataItem.get("geometry"), this);
    }
    /**
     * @ignore
     */ disposeDataItem(dataItem) {
        super.disposeDataItem(dataItem);
        const mapPolygon = dataItem.get("mapPolygon");
        if (mapPolygon) {
            this.mapPolygons.removeValue(mapPolygon);
            mapPolygon.dispose();
        }
        this._removeGeometry(dataItem.get("geometry"));
    }
    /**
     * @ignore
     */ _excludeDataItem(dataItem) {
        super._excludeDataItem(dataItem);
        const mapPolygon = dataItem.get("mapPolygon");
        if (mapPolygon) {
            mapPolygon.setPrivate("visible", false);
        }
    }
    /**
     * @ignore
     */ _unexcludeDataItem(dataItem) {
        super._unexcludeDataItem(dataItem);
        const mapPolygon = dataItem.get("mapPolygon");
        if (mapPolygon) {
            mapPolygon.setPrivate("visible", true);
        }
    }
    /**
     * @ignore
     */ _notIncludeDataItem(dataItem) {
        super._notIncludeDataItem(dataItem);
        const mapPolygon = dataItem.get("mapPolygon");
        if (mapPolygon) {
            mapPolygon.setPrivate("visible", false);
        }
    }
    /**
     * @ignore
     */ _unNotIncludeDataItem(dataItem) {
        super._unNotIncludeDataItem(dataItem);
        const mapPolygon = dataItem.get("mapPolygon");
        if (mapPolygon) {
            mapPolygon.setPrivate("visible", true);
        }
    }
    /**
     * Forces a repaint of the element which relies on data.
     *
     * @since 5.0.21
     */ markDirtyValues(dataItem) {
        super.markDirtyValues();
        if (dataItem) {
            const mapPolygon = dataItem.get("mapPolygon");
            if (mapPolygon) {
                mapPolygon.set("geometry", dataItem.get("geometry"));
            }
        }
    }
    /**
     * Centers and zooms in on the specific polygon.
     *
     * @param  dataItem  Target data item
     * @see {@link https://www.amcharts.com/docs/v5/charts/map-chart/map-pan-zoom/#Zooming_to_clicked_object} for more info
     * @param  rotate If it's true, the map will rotate so that this polygon would be in the center. Mostly usefull with geoOrthographic projection.
     */ zoomToDataItem(dataItem, rotate) {
        const polygon = dataItem.get("mapPolygon");
        if (polygon) {
            const geometry = polygon.get("geometry");
            const chart = this.chart;
            if (geometry && chart) {
                if (rotate) {
                    const centroid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.getGeoCentroid(geometry);
                    chart.rotate(-centroid.longitude, -centroid.latitude);
                    return chart.zoomToGeoBounds(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.getGeoBounds(geometry), undefined, -centroid.longitude, -centroid.latitude);
                }
                return chart.zoomToGeoBounds(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.getGeoBounds(geometry));
            }
        }
    }
    /**
     * Zooms the map in so that all polygons in the array are visible.
     *
     * @param   dataItems  An array of data items to zoom to
     * @param   rotate     Rotate the map so it is centered on the selected items
     * @return             Animation
     * @since 5.9.0
     */ zoomToDataItems(dataItems, rotate) {
        let left;
        let right;
        let top;
        let bottom;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$util$2f$Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.each(dataItems, (dataItem)=>{
            const polygon = dataItem.get("mapPolygon");
            if (polygon) {
                const geometry = polygon.get("geometry");
                if (geometry) {
                    let bounds = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.getGeoBounds(geometry);
                    if (left == null) {
                        left = bounds.left;
                    }
                    if (right == null) {
                        right = bounds.right;
                    }
                    if (top == null) {
                        top = bounds.top;
                    }
                    if (bottom == null) {
                        bottom = bounds.bottom;
                    }
                    left = Math.min(bounds.left, left);
                    right = Math.max(bounds.right, right);
                    top = Math.max(bounds.top, top);
                    bottom = Math.min(bounds.bottom, bottom);
                }
            }
        });
        if (left != null && right != null && top != null && bottom != null) {
            const chart = this.chart;
            if (chart) {
                if (rotate) {
                    const rx = left + (right - left) / 2;
                    const ry = bottom + (top - bottom) / 2;
                    chart.rotate(-rx, -ry);
                    return chart.zoomToGeoBounds({
                        left,
                        right,
                        top,
                        bottom
                    }, undefined, -rx, -ry);
                }
                return chart.zoomToGeoBounds({
                    left,
                    right,
                    top,
                    bottom
                });
            }
        }
    }
    /**
     * Returns a [[MapPolygon]] that is under specific X/Y point.
     *
     * @since 5.9.8
     * @param   point  X/Y
     * @return         Polygon
     */ getPolygonByPoint(point) {
        let found;
        const renderer = this._display._renderer;
        const displayObject = renderer.getObjectAtPoint(point);
        if (displayObject) {
            this.mapPolygons.each(function(polygon) {
                if (polygon._display == displayObject) {
                    found = polygon;
                }
            });
            return found;
        }
    }
    getPolygonByGeoPoint(point) {
        return this.getPolygonByPoint(this.chart.convert(point));
    }
}
Object.defineProperty(MapPolygonSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "MapPolygonSeries"
});
Object.defineProperty(MapPolygonSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$charts$2f$map$2f$MapSeries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MapSeries"].classNames.concat([
        MapPolygonSeries.className
    ])
}); //# sourceMappingURL=MapPolygonSeries.js.map

})()),
"[project]/node_modules/@amcharts/amcharts5/.internal/charts/map/ZoomControl.js [app-ssr] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {
"use strict";

__turbopack_esm__({
    "ZoomControl": ()=>ZoomControl
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$ZoomTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@amcharts/amcharts5/.internal/core/render/ZoomTools.js [app-ssr] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
class ZoomControl extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$ZoomTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ZoomTools"] {
    _afterNew() {
        super._afterNew();
        this.addTag("zoomtools");
    }
    _prepareChildren() {
        super._prepareChildren();
        if (this.isPrivateDirty("chart")) {
            this.set("target", this.getPrivate("chart"));
        }
    }
}
Object.defineProperty(ZoomControl, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "ZoomControl"
});
Object.defineProperty(ZoomControl, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$amcharts$2f$amcharts5$2f2e$internal$2f$core$2f$render$2f$ZoomTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ZoomTools"].classNames.concat([
        ZoomControl.className
    ])
}); //# sourceMappingURL=ZoomControl.js.map

})()),

};

//# sourceMappingURL=node_modules_%40amcharts_amcharts5__internal_charts_map_a93a82._.js.map